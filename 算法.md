# 算法

## 剑指offer

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

![image-20211101142120903](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20211101142120903.png)

```java
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            strs[i] = String.valueOf(nums[i]);//转为字符串
        }
        quickSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for (String s : strs)
            res.append(s);
        return res.toString();
    }
	//快速排序
    public void quickSort(String[] strs, int low, int high) {
        if (low < high) {
            int middle = getMiddle(strs, low, high);
            quickSort(strs, low, middle - 1);
            quickSort(strs, middle + 1, high);
        }
    }
	//找分割点
    public int getMiddle(String[] strs, int low, int high) {
        String pivot = strs[high];
        int i = low -1;
        for (int j = low; j < high; j++) {
            if ((strs[j] + pivot).compareTo(pivot + strs[j]) <= 0){
                swap(strs, ++i, j);
            }
        }
        swap(strs, i+1, high);
        return i+1;
    }
	//交换数据
    private void swap(String[] strs, int i, int j) {
        String temp = strs[i];
        strs[i] = strs[j];
        strs[j] = temp;
    }
}
```

## 算法思想

### [递归算法](https://www.youtube.com/watch?v=IJDJ0kBx2LM)

递归就是方法自己调用自己，要有停止条件

两个问题：

1. base case 是什么
2. 每次迭代的时候最小工作量是什么

#### 优缺点

|              优点              |            缺点            |
| :----------------------------: | :------------------------: |
|       代码优雅与思维复杂       |       CPU开销导致慢        |
|   减少复杂循环与辅助数据结构   |   可能导致内存/堆栈溢出    |
|     利用内存减少时间复杂度     | 若构造不好，会不必要的复杂 |
| 适合递归算法的数据结构，数或图 |                            |

算法例子：

1. 反转字符串

   ![image-20230104100119935](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20230104100119935.png)

2. 判断是否为回文字符串

   ![image-20230104095823802](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20230104095823802.png)

3. 十进制转二进制

   ```java
   public class DecimalToBinary {
       public static void main(String[] args){
           String binary = findBinary(233, "");
           System.out.print(binary);
       }
   
       public static String findBinary(int decimal, String result){
           if(decimal == 0){
               return result;
           }
   
           result = decimal % 2 + result;
           return findBinary( decimal / 2, result);
       }
   }
   ```

4. 自然数和

   ```java
   public class SumOfNaturalNumbers {
       public static void main(String[] args){
           int result = recursiveSummation(10);
           System.out.print(result);
       }
       public static int recursiveSummation(int inputNumber){
           if(inputNumber <= 1){
               return inputNumber;
           }
           return inputNumber + recursiveSummation(inputNumber - 1);
       }
   }
   ```

#### 分而治之

1. 将问题划分为几个较小的子问题**(通常情况下，子问题与原问题相似)**
2. 通过递归求解来征服子问题基本情况:通过暴力解决足够小的问题
3. 将解组合起来得到子问题的解，最终得到原问题的解
4. 分治算法通常是递归的

场景：二分查找，斐波那契数列，归并排序，反转列表，合并有序列表, 树

归并排序

```java
public class MergeSort {
    public static void main(String[] args){

        int[] data = new int[]{-5, 2, 7, -3, 4};
        mergeSort(data, 0, data.length - 1);
        for(int i = 0; i < data.length; i++){
            System.out.println(data[i]);
        }
    }

    public static void mergeSort(int[] data, int left, int right){
        if(left < right){
            int mid = (left + right) / 2;
            mergeSort(data, left, mid);
            mergeSort(data, mid + 1, right);
            merge(data, left, mid, right);
        }
    }

    public static void merge(int[] data, int left, int mid, int right){
        //build temp array to avoid modifying the original contents
        int[] temp = new int[right - left + 1];

        int i = left, j = right, k = 0;
        //while both sub-array have values, then try and merge them in sorted order
        while(i <= mid && j <= right){
            if(data[i] <= data[j]){
                temp[k++] = data[i++];

            }else{
                temp[k++] = data[j++];
            }
        }
        //add the rest of the values from the left sub-array into the result
        while(i <= mid){
            temp[k] = data[i];
            k++; i++;
        }
        //add the rest of the values form the right sub-array into the result
        while(j <= right){
            temp[k] = data[j];
            k++; j++;
        }
        for(i = left; i <= right; i++){
            data[i] = temp[i - left];
        }
    }
}
```

反转列表

```java
public class ReverseLinkedList {
    static class Node{
        private int val;
        private Node next;
        public Node(int val){
            this.val = val;
        }

        public void setNext(Node node){
            this.next = node;
        }

        public Node getNext(){
            return next;
        }
    }

    public static void main(String[] args){
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);
        Node n5 = new Node(5);

        n1.setNext(n2);
        n2.setNext(n3);
        n3.setNext(n4);
        n4.setNext(n5);

        printLinkedList(n1);
        Node p = reverseLinkedList(n1);
        printLinkedList(p);
    }

    public static void printLinkedList(Node node){
        Node temp = node;
        while(temp != null){
            System.out.print(temp.val + " ");
            temp = temp.getNext();
        }
    }

    public static Node reverseLinkedList(Node node){
        if(node == null || node.next == null){
            return node;
        }
        Node p = reverseLinkedList(node.next);
        node.next.next = node;
        node.next = null;
        return p;
    }
}
```

合并有序列表

```java
public class MergeTwoSortedLists {
    static class Node{
        private int val;
        private Node next;
        public Node(int val){
            this.val = val;
        }

        public void setNext(Node node){
            this.next = node;
        }

        public Node getNext(){
            return next;
        }
    }

    public static void main(String[] args){
        Node n1 = new Node(1);
        Node n2 = new Node(5);
        Node n3 = new Node(13);
        Node n4 = new Node(14);
        Node n5 = new Node(550);

        Node n1_1 = new Node(2);
        Node n2_2 = new Node(15);
        Node n3_3 = new Node(130);
        Node n4_4 = new Node(200);
        Node n5_5 = new Node(350);

        n1.setNext(n2);
        n2.setNext(n3);
        n3.setNext(n4);
        n4.setNext(n5);

        n1_1.setNext(n2_2);
        n2_2.setNext(n3_3);
        n3_3.setNext(n4_4);
        n4_4.setNext(n5_5);

        Node sortedMerge = mergeLists(n1, n1_1);
        printLinkedList(sortedMerge);
    }

    public static void printLinkedList(Node node){
        Node temp = node;
        while(temp != null){
            System.out.print(temp.val + " ");
            temp = temp.getNext();
        }
    }

    public static Node mergeLists(Node l1, Node l2){
        if(l1 == null){
            return l2;
        }
        if(l2 == null){
            return l1;
        }

        if(l1.val <= l2.val){
            l1.next = mergeLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeLists(l1, l2.next);
            return l2;
        }
    }
}

```

二叉树

```java
import java.util.List;

public class PrintLeafTreeNodes {
    static class TreeNode{
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode(){

        }

        public TreeNode(int val){
            this.val = val;
        }
    }

    public static void main(String[] args){
        List<Integer> dataInput = List.of(100, 80, 50, 90, 30, 60, 85, 95, 120, 110, 108, 115, 140, 150);
        TreeNode root = null;
        for(Integer node : dataInput){
            root = insertNode(root, node);
        }
        printLeaves(root);//输出的是叶子节点
    }

    public static TreeNode insertNode(TreeNode root, int data){
        if(root == null){
            root = new TreeNode();
            root.val = data;
            return root;
        }
        if(root.val < data){
            root.right = insertNode(root.right, data);
        }else{
            root.left = insertNode(root.left, data);
        }
        return root;
    }
    //输出叶子节点
    public static void printLeaves(TreeNode root){
        if(root == null) return;
        //checks if a given node is a leaf
        if(root.left == null && root.right == null){
            System.out.print(root.val + " ");
            return;
        }

        if(root.left != null){
            printLeaves(root.left);
        }

        if(root.right != null){
            printLeaves(root.right);
        }
    }
}

```

### [动态规划](https://www.youtube.com/watch?v=oBt53YbR9Kk&t=202s)

总结：

![image-20230110211423258](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20230110211423258.png)



递归：保存计算结果

![image-20230110211721651](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20230110211721651.png)

制表方法：

![image-20230110212329660](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20230110212329660.png)



#### 问题一、斐波那契数列