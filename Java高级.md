### Java高级

#### 多线程

1. **程序(program)**是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段**静态的代码，静态对象**。

2. **进程(process)**是**程序的一次执行过程**，或是正在运行的一个程序。是一个动态 的过程：有它自身的**产生、存在和消亡**的过程。——生命周期

   - 程序是静态的，进程是动态的
   - **进程作为资源分配的单位，**系统在运行时会为每个进程分配不同的内存区域

3. **线程(thread)**，进程可进一步细化为线程，是一个程序内部的一条执行路径。

   - 若一个进程同一时间并行执行多个线程，就是支持多线程的
   - **线程作为调度和执行的单位**，每个线程拥有独立的**运行栈**和**程序计数器(pc)**，**线程切换的开 销小**
   - 一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但**多个线程操作共享的系统资 源可能就会带来安全的隐患**

4. **多线程的创建和使用**

   - **多线程的创建**

     - **方式一：继承于Thread类**

       1. ```
          1. 创建一个继承于Thread类的子类
          2. 重写Thread类的run() --> 将此线程执行的操作声明在run()中
          3. 创建Thread类的子类的对象
          4. 通过此对象调用start()：作用：①启动当前线程②调用当前线程的run()
          ```

     - 创建Thread类的匿名子类的方式

     - **方式二：实现Runnable接口**

       1. 创建一个实现了Runnable接口的类
       2. 实现类中实现Runnable接口中的抽象方法run()
       3. 创建实现类的对象
       4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
       5. 通过Thread类的对象调用start().
          - 启动线程
          - 调用当前线程的run()——>调用了Runnable类型的target的run()

     - **比较两种线程创建方式**

       1. 开发中优先选用实现Runnable的方法创建线程
          - 实现的方式没有类的单继承的局限性
          - 实现的方式更适合来处理多个线程有共享数据的情况
       2. 联系：public   class  Thread  implements  Runnable
       3. 相同点：两种方法都需要重写run()方法，将线程要执行的逻辑声明在run()中。

     - 

   - Thread类中常用方法

     - 1、start():启用当前线程：调用当前线程的run();
     - 2、run()：重写Thread类中的此方法，创建的线程要执行的操作声明在此方法中
     - 3、currentThread()：静态方法，返回执行当前代码的线程
     - 4、getName():获取当前线程的名字
     - 5、setName():设置当前线程的名字
     - 6、yield():释放当前线程的执行权
     - 7、join():在线程a中调用线程b的join方法，则线程a阻塞，直到线程b完全执行完以后，线程a才结束阻塞状态
     - 8、stop（）：强制线程结束生命周期（已过时）
     - 9、sleep（long  millitime）：让当前线程睡眠指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程处于阻塞状态
     - 10、isAlive():判断当前线程是否存活

   - 线程的优先级

     - ```
       * MAX_PRIORITY：10
       * MIN _PRIORITY：1
       * NORM_PRIORITY：5  -->默认优先级
       ```

     - 如何获取和设置当前线程的优先级：

       1. getPriority():获取线程的优先级
       2. setPriority():设置线程的优先级
       3. **高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲**，高优先级的线程高概率的情况下执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。

   - **线程的生命周期**

     1. ![image-20210817091413948](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210817091413948.png)

   - **线程的同步**

     1. 在Java中通过同步机制，解决线程的安全问题
     2. **方式一同步代码块**
        - **synchronized(同步监视器){//需要被同步的代码}**
        - **操作共享数据的代码，即为需要被同步的代码**——>不能包含代码多了，也不能包含代码少了
        - 共享数据：多个线程共同
        - **同步监视器**：俗称**锁**任何一个类的对象都可以充当锁
        - 要求：多个线程必须要共用同一把锁。
        - 在实现Runnable接口创建多线程的方式中，可以考虑使用this充当同步监视器
     3. **方式二同步方法**
        - 如果操作共享数据的代码完整的声明在一个方法中，我们将此方法声明同步的。
        - 同步方法仍然涉及到同步监视器，只是不需要显式的声明
        - 非静态的同步方法，同步监视器是this
        - **静态的同步方法，同步监视器是：当前类本身**
     4. 同步的方式，解决了线程的安全问题。--好处；操作同步代码时，只能一个线程参与，其它线程等待，相当于一个单线程的过程，效率低

   - **线程的死锁**

     1. 死锁的理解：不同的线程占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
     2.  说明：
        - 出现死锁后不会出现异常，不会出现提示，只是所有的线程处于阻塞状态，无法继续
        - 使用同步时，避免出现死锁

   - 解决线程安全问题的方式三：**Lock锁**    ------JDK5.0新增

     1. 实例化ReentrantLock
     2. 调用锁定方法lock();
     3. 调用解锁方法unlock();

   - **synchronized和lock的异同？**

     - 都可以解决线程安全问题

     - synchronized机制在执行完相应的同步代码以后，自动释放同步监视器：Lock需要手动的启动同步（Lock()）手动结束同步（unlock()）;

     - 优先使用顺序：

       ①Lock（）②同步代码块（已经进入了方法体，分配了相应资源）③同步方法（在方法体外）

   - **如何解决线程安全问题？有几种方式**

     - 三种方式

   - **线程的通信**

     - 三种方法：
       1. **wait():**一旦执行此方法，当前线程进入阻塞状态，并释放同步监视器
       2. **notify():**执行此方法，就会唤醒被wait()的线程，若有多个线程，唤醒优先级最高的线程
       3. **notifyAll():**唤醒所有被wait()的线程。
     - 三种方法必须使用在**同步代码块或同步方法中**
     - 三个方法的**调用者**，必须是**同步代码块或同步方法中的同步监视器**；否则会出现**IllegalMonitorstateException**异常
     - 三个方法定义在java.lang.Object类中

   - **面试题：**

     1. **sleep（）和wait()方法的异同**
        - 相同点:一旦执行方法，都可以是当前线程进入阻塞状态
        - 不同点：
          - 声明的位置不同：Thread类中声明sleep()方法；Object类中声明wait()方法
          - 调用的范围不同：sleep()可以在任何需要的场景下调用。**wait()必须使用在同步代码块或同步方法中**
          - **关于是否释放同步监视器**：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait（）会释放锁

   - **JDK5.0新增线程创建方式**

     1. 方式一：**实现Callable接口**
        - 相比run()方法，可以有返回值
        - 方法可以抛出异常
        - 支持泛型的返回值
        - 需要借助FutureTask类，比如获取返回结果
     2. 方式二：**使用线程池**
        1. 好处：
           - 提高响应速度（减少创建新线程时间）
           - 降低资源消耗（重复利用线程池中线程，不需要每次都创建）
           - 便于线程管理
             - corePoolSize:核心池的大小
             - maximumPoolSize:最大线程数
             - keepAliveTime:线程没有任务时最多保持多长时间后会终止

5. 一个Java应用程序java.exe,其中至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。如果发生异常，会影响主线程。

#### 常用类

##### 字符串相关的类

1. String：字符串	使用一对“”引起来表示
   - string声明为final，不可被继承
   - string实现了Serializable接口：表示字符串是支持序列化的
   - 实现类Comparable接口：表示String可以比较大小
   - String内部定义了final  char[]   value用于存储字符串数据
   - String：代表不可变的字符序列。简称：不可变性
     - **当对字符串重新赋值时**，需要重写指定内存区域赋值，不能使用原有value赋值
     - **当对现有的字符串进行连接操作时**，需要重写指定内存区域赋值，不能使用原有value修改
     - 当调用string的replace方法修改指定字符或字符串时，需要重写指定内存区域赋值，不能使用原有value修改
   - 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在**字符串常量池**中
   - 字符串常量池中不会存储相同内容的字符串的。
2. String：实例化方式
   - 方式一：通过字面量定义的方式：**方法区的字符串常量池中**
   - 方式二;通过new + 构造器的方式：数据在**堆空间**中
   - 面试题：String s = new String("abc");方式创建对象，在内存中创建了几个对象？
                 两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据："abc"
   - 结论：
     - 常量与常量的拼接结果在常量池中，且常量池中不会存在相同内容的常量
     - 只要其中有一个是变量，结果就在堆中。
     - 如果拼接的结果调用intern()方法，返回值就在常量池中
3. **String与基本数据类型和包装类**之间的转换
   - String——>基本数据类型，包装类，调用包装类的静态方法：parseXxx(str)
   - 基本数据类型，包装类——>String,调用String重载的valueOf(xxx)
4. **String与char[]数组之间的转换**
   - String——>char[],调用String类的toCharArray()
   - char[]——>String，调用String的构造器
5. **String与byte[]数组之间的转换**
   - 编码String——>byte[],调用String类的getBytes()
   - 解码：byte[]——>String，调用String类的构造器
     - **编码**：字符串——>字节（看的懂——>看不懂二进制数据）
     - **解码：编码的逆过程**，字节——>字符串（看不懂二进制数据——>看的懂）
     - 解码时要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码
6. **StringBuffer和StringBuilder使用**
   - **String与StringBuffer和StringBuilder异同**
     1. String：不可变字符序列，底层使用char[]存储
     2. StringBuffer:可变的字符序列，**线程安全的，效率低**；底层使用char[]存储
     3. StringBuilder：可变的字符序列，**线程不安全，效率高  jdk5.0新增**；底层使用char[]存储
     4. 三者的效率：StringBuilder  >  StringBuffer   >   String

##### 日期和时间API

1. JDK8.0之前的日期和时间API
   - System类中的currentTimeMillis()  称为**时间戳**
2. java.util.Date类

