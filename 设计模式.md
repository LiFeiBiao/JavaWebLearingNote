# 设计模式

https://mp.weixin.qq.com/s/yEAdDRijRav9bYgvR8a8QQ

## 认识

设计模式(Design Pattern)是前辈们经过相当长的一段时间的试验和错误总结出来的，是软件开发过程中面临的通用问题的解决方案。这些解决方案使用设计模式是为了**可重用代码**、**让代码更容易被他人理解、保证代码可靠性**。

## 分类

1）根据其目的
即模式是用来做什么的，可分为**创建型(Creational)**，**结构型(Structural)**和**行为型(Behavioral)**三种：
①创建型模式主要用于创建对象。
②结构型模式主要用于处理类或对象的组合。
③行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。

（2） 根据范围
即模式主要是**用于处理类之间关系还是处理对象之间的关系**，可分为类模式和对象模式两种：
类模式处理**类和子类**之间的关系，这些关系通过**继承建立**，在编译时刻就被确定下来，是**属于静态**的。

![image-20211020082222045](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20211020082222045.png)

## 优点

①可以提高程序员的**思维能力、编程能力和设计能力**。
②使程序设计更加标准化、代码编制更加工程化，**使软件开发效率大大提高，从而缩短软件的开发周期**。
③使设计的**代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强**。

（1）创建型模式：
**简单工厂**：**一个工厂类根据传入的参量决定创建出那一种产品类的实例。**
**工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。**
抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。
建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。
**单例模式：某个类只能有一个实例，提供一个全局的访问点。Spring 中的 Bean 默认都是单例的。**
原型模式：通过复制现有的实例来创建新的实例。
（2）**结构型模式**
外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。
桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。
组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。
装饰模式：动态的给对象添加新的功能。
**代理模式：为其他对象提供一个代理以便控制这个对象的访问。Spring AOP 功能的实现。**
**适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。**
亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。
（3）行为型模式
**模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。**
解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。
策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
状态模式：允许一个对象在其对象内部状态改变时改变它的行为。
**观察者模式：对象间的一对多的依赖关系。**
备忘录模式：在不破坏封装的前提下，保持对象的内部状态。
中介者模式：用一个中介对象来封装一系列的对象交互。
命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。

## 设计原则https://blog.csdn.net/yucaixiang/article/details/90239817

- **单一职责**

  一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。单一职责原则是实现**高内聚、低耦合**的指导方针

- **开闭原则**

  一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展

- **里氏替换原则**

  里氏代换原则(Liskov Substitution Principle, LSP)**：所有引用基类（父类）的地方必须能透明地使用其子类的对象。**

- **依赖倒置原则**

  **高层模块不应该依赖低层模块**，两者都应该**依赖其抽象**；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：**要面向接口编程，不要面向实现编程。**

- **接口原则**

  使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

- **迪米特法则**

  迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。

## spring中用到的设计模式

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring **AOP 功能的实现**。
- **单例设计模式** : Spring 中的 **Bean 默认都是单例的**。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **装饰器模式** : 我们的项目需要**连接多个数据库**，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们**可以根据客户的需求能够动态切换不同的数据源**。
- **观察者模式:** **Spring 事件驱动模型**就是观察者模式很经典的一个应用。
- **适配器模式** :**Spring AOP 的增强或通知(Advice)使用到了适配器模式**、spring MVC 中也是用到了适配器模式适配`Controller`。

## 简单工厂模式

简单地说，简单工厂模式通常就是这样，**一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象**

```java
public class FoodFactory {

    public static Food makeFood(String name) {
        if (name.equals("noodle")) {
            Food noodle = new LanZhouNoodle();
            noodle.addSpicy("more");
            return noodle;
        } else if (name.equals("chicken")) {
            Food chicken = new HuangMenChicken();
            chicken.addCondiment("potato");
            return chicken;
        } else {
            return null;
        }
    }
}
```

我们强调**职责单一**原则，**一个类只提供一种功能**，FoodFactory 的功能就是只要负责生产各种 Food。

## 工厂模式

简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂

第一步，我们**需要选取合适的工厂**，然后第二步基本上和简单工厂一样。

**核心在于，我们需要在第一步选好我们需要的工厂**。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。

## 抽象工厂模式

当涉及到**产品族**的时候，就需要引入抽象工厂模式了。

当涉及到这种产品族的问题的时候，就需要**抽象工厂模式**来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们**直接定义电脑工厂**，**每个电脑工厂负责生产所有的设备**，这样能保证肯定不存在兼容问题。

违反了**对修改关闭，对扩展开放**这个设计原则。

## 模板方法模式

在含有继承结构的代码中，模板方法模式是非常常用的。

```java
public abstract class AbstractTemplate {
    // 这就是模板方法
    public void templateMethod() {
        init();
        apply(); // 这个是重点
        end(); // 可以作为钩子方法
    }
    protected void init() {
        System.out.println("init 抽象层已经实现，子类也可以选择覆写");
    }
    // 留给子类实现
    protected abstract void apply();
    protected void end() {
    }
}
```

模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，**模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现**

```java
public class ConcreteTemplate extends AbstractTemplate {
    public void apply() {
        System.out.println("子类实现抽象方法 apply");
    }

    public void end() {
        System.out.println("我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了");
    }
}
```

## 观察者模式

观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，**观察者订阅自己关心的主题和主题有数据变化后通知观察者们。**

首先，**需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：**

```java
public class Subject {
    private List<Observer> observers = new ArrayList<Observer>();
    private int state;
    public int getState() {
        return state;
    }
    public void setState(int state) {
        this.state = state;
        // 数据已变更，通知观察者们
        notifyAllObservers();
    }
    // 注册观察者
    public void attach(Observer observer) {
        observers.add(observer);
    }
    // 通知观察者们
    public void notifyAllObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}
```

定义观察者接口：

```java
public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}
```

其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。

```java
public class BinaryObserver extends Observer {
    // 在构造方法中进行订阅主题
    public BinaryObserver(Subject subject) {
        this.subject = subject;
        // 通常在构造方法中将 this 发布出去的操作一定要小心
        this.subject.attach(this);
    }
    // 该方法由主题类在数据变更的时候进行调用
    @Override
    public void update() {
        String result = Integer.toBinaryString(subject.getState());
        System.out.println("订阅的数据发生变化，新的数据处理为二进制值为：" + result);
    }
}

public class HexaObserver extends Observer {
    public HexaObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }
    @Override
    public void update() {
        String result = Integer.toHexString(subject.getState()).toUpperCase();
        System.out.println("订阅的数据发生变化，新的数据处理为十六进制值为：" + result);
    }
}
```

客户端使用也非常简单：

```java
public static void main(String[] args) {
    // 先定义一个主题
    Subject subject1 = new Subject();
    // 定义观察者
    new BinaryObserver(subject1);
    new HexaObserver(subject1);

    // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用
    subject.setState(11);
}
```

jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。

**实际生产过程中，观察者模式往往用消息中间件来实现**

核心的部分，那就是**一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。**

## 适配器模式

适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。

## 装饰者模式

**装饰者模式可以动态地给对象添加一些额外的属性或行为**。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 `InputStream`家族，`InputStream` 类下有 `FileInputStream` (读取文件)、`BufferedInputStream` (增加缓存,使读取文件速度大大提升)等子类都在不修改`InputStream` 代码的情况下扩展了它的功能。

## 单例设计模式

https://mp.weixin.qq.com/s/HlF_HXB9IdENPT307y8zJQ

1. 单例设计模式

   - **所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。**

2. **懒汉式和饿汉式**

   - 懒汉式

     - 好处：延迟对象的创建。

     - 目前的写法坏处：线程不安全。--->到多线程内容时，再修改

       ```java
       //饿汉式
       class Bank{
       	//1.私有化类的构造器
       	private Bank(){	
       	}
       	//2.内部创建类的对象
       	//4.要求此对象也必须声明为静态的
       	private static Bank instance = new Bank();
       	//3.提供公共的静态的方法，返回类的对象
       	public static Bank getInstance(){
       		return instance;
       	}
       }
       ```

     - 线程安全的懒汉式单例模式

       ```java
       class Bank{
           private Bank(){}
           private static Bank instance = null;
           public static Bank getInstance(){
               
               //方式一：效率稍差
       //        synchronized (Bank.class) {
       //            if(instance == null){
       //                instance = new Bank();
       //            }
       //            return instance;
       //        }
               
               //方式二：效率更高
               if(instance == null){
                   synchronized (Bank.class) {
                       if(instance == null){
                           instance = new Bank();
                       }
                   }
               }
               return instance;
           }
       }
       ```

       

   - 饿汉式

     - 坏处：对象加载时间过长。

     - 好处：饿汉式是线程安全的

       ```java
       class Order{
       	//1.私有化类的构造器
       	private Order(){
       	}
       	//2.声明当前类对象，没有初始化
       	//4.此对象也必须声明为static的
       	private static Order instance = null;
       	//3.声明public、static的返回当前类对象的方法
       	public static Order getInstance(){
       		if(instance == null){
       			instance = new Order();
       		}
       		return instance;
       	}
       }
       ```

## 代理模式

https://mp.weixin.qq.com/s/KoJJ2BYv08rzF2HcjCGtzg

**结构型**设计模式，**即通过代理对象访问目标对象。**

**可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。**

这里使用到编程中的一个思想：**不要随意去修改别人已经写好的代码或者方法，如果需要修改，可以通过代理的方式来扩展该方法**。

**三大角色：**

- `Real Subject`：**真实类**，也就是被代理类、委托类。用来真正完成业务服务功能；
- `Proxy`：**代理类**，将**自身的请求用 Real Subject 对应的功能来实现**，代理类对象并不真正的去实现其业务功能；
- `Subject`：**定义 RealSubject 和 Proxy 角色都应该实现的接口。**

**三种类型：**

**静态代理**，**动态代理**（JDK代理，接口代理）、**Cglib代理**（在内存中动态的创建目标对象的**子类**）

### 静态代理

静态代理需要**先定义接口**，**被代理对象与代理对象一起实现相同的接口**，然后**通过调用相同的方法来调用目标对象的方法**。

- 优点：**静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展**。
- 缺点：静态代理实现了目标对象的所有方法，一旦**目标接口增加方法**，代理对象和目标对象都要进行相应的修改，增加维护成本。`

```java
package com.atguigu.java;

/**
 * 静态代理举例
 * 特点：代理类和被代理类在编译期间，就确定下来了。
 */
interface ClothFactory{
    void produceCloth();
}

//被代理类
class NikeClothFactory implements ClothFactory{
    @Override
    public void produceCloth() {
        System.out.println("Nike工厂生产一批运动服");
    }
}

//代理类
class ProxyClothFactory implements ClothFactory{
    private ClothFactory factory;//用被代理类对象进行实例化
    public ProxyClothFactory(ClothFactory factory){
        this.factory = factory;
    }
    @Override
    public void produceCloth() {
        System.out.println("代理工厂做一些准备工作");
        factory.produceCloth();
        System.out.println("代理工厂做一些后续的收尾工作");
    }
}


public class StaticProxyTest {
    public static void main(String[] args) {
        //创建被代理类的对象
        ClothFactory nike = new NikeClothFactory();
        //创建代理类的对象
        ClothFactory proxyClothFactory = new ProxyClothFactory(nike);
        proxyClothFactory.produceCloth();

    }
}
```

### 动态代理

**特点：**

- JDK动态代理对象**不需要实现接口**，**只有目标对象需要实现接口**。
- 实现基于接口的动态代理需要利用**JDK中的API**，在**JVM内存中动态的构建Proxy对象**。
- 需要使用到 **java.lang.reflect.Proxy**，和其**newProxyInstance方法**，但是该方法需要接收三个参数。

**newProxyInstance方法是静态方法**，且接收的三个参数依次为：

- `ClassLoader loader`：指定**当前目标对象使用类加载器**，**获取加载器的方法是固定的**。
- `Class<?>[] interfaces`：**目标对象实现的接口的类型**，使用泛型方式确认类型。
- `InvocationHandler h`：**事件处理，执行目标对象的方法时**，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。

**总结：**

- `代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能用动态代理。`
- `动态代理的方式中，所有的函数调用最终都会经过 invoke 函数的转发，因此我们就可以在这里做一些自己想做的操作，比如日志系统、事务、拦截器、权限控制等。`

> JDK 动态代理有一个最致命的问题是它只能代理实现了某个接口的实现类，并且代理类也只能代理接口中实现的方法，要是实现类中有自己私有的方法，而接口中没有的话，该方法不能进行代理调用。

1. 想实现动态代理需要解决的问题：

   1. 如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象？
   2. 当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法？

2. ```java
   package com.atguigu.java;
   
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.Method;
   import java.lang.reflect.Proxy;
   
   /**
    * 动态代理的举例
    */
   
   interface Human{
       String getBelief();
       void eat(String food);
   }
   //被代理类
   class SuperMan implements Human{
       @Override
       public String getBelief() {
           return "I believe I can fly!";
       }
       @Override
       public void eat(String food) {
           System.out.println("我喜欢吃" + food);
       }
   }
   
   class HumanUtil{
       public void method1(){
           System.out.println("====================通用方法一====================");
       }
       public void method2(){
           System.out.println("====================通用方法二====================");
       }
   }
   
   /*
   要想实现动态代理，需要解决的问题？
   问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。
   问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。
    */
   
   class ProxyFactory{
       //调用此方法，返回一个代理类的对象。解决问题一
       public static Object getProxyInstance(Object obj){//obj:被代理类的对象
           MyInvocationHandler handler = new MyInvocationHandler();
           handler.bind(obj);
           return Proxy.newProxyInstance(obj.getClass().getClassLoader(),
                                         obj.getClass().getInterfaces(),
                                         handler);
       }
   }
   
   class MyInvocationHandler implements InvocationHandler{
   
       private Object obj;//需要使用被代理类的对象进行赋值
       public void bind(Object obj){
           this.obj = obj;
       }
       //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()
       //将被代理类要执行的方法a的功能就声明在invoke()中
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           HumanUtil util = new HumanUtil();
           util.method1();
           //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
           //obj:被代理类的对象
           Object returnValue = method.invoke(obj,args);
           util.method2();
           //上述方法的返回值就作为当前类中的invoke()的返回值。
           return returnValue;
       }
   }
   
   public class ProxyTest {
       public static void main(String[] args) {
           SuperMan superMan = new SuperMan();
           //proxyInstance:代理类的对象
           Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
           //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法
           String belief = proxyInstance.getBelief();
           System.out.println(belief);
           proxyInstance.eat("四川麻辣烫");
   
           System.out.println("*****************************");
   
           NikeClothFactory nikeClothFactory = new NikeClothFactory();
   
           ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);
   
           proxyClothFactory.produceCloth();
   
       }
   }
   ```

### **Cglib代理**

静态代理和JDK代理都需要某个对象实现一个接口，有时候代理对象只是一个单独对象，此时可以使用Cglib代理。

![图片](https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0dmc1oQbRFJrGFqzZl8yeZHt9gMML1nOjYTznpmG6h1iccIkSib1OXOMs024qtmRl3Bg5FH18jLsBJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

Cglib代理可以称为**子类代理**，**是在内存中构建一个子类对象**，从而**实现对目标对象功能的扩展**。

Cglib通过`Enhancer` **来生成代理类**，通过实现`MethodInterceptor`接口，并实现其中的`intercept`方法，在此方法中可以**添加增强方法，**并可以利用反射`Method`或者`MethodProxy`**继承类 来调用原方法**。

**如果目标对象需要实现接口，则使用JDK代理。**

**如果目标对象不需要实现接口，则使用Cglib代理。**

1. `静态代理`：需要代理类和目标类都实现接口的方法，从而达到代理增强其功能。
2. `JDK动态代理`：需要代理类实现某个接口，使用`Proxy.newProxyInstance`方法生成代理类，并实现`InvocationHandler`中的`invoke`方法，实现增强功能。
3. `Cglib动态代理`：**无需代理类实现接口**，使用`Cblib`中的`Enhancer`来**生成代理对象子类**，并实现`MethodInterceptor`中的`intercept`方法，在此方法中可以实现增强功能。

**总结：**

用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。

既然说是**代理**，那就要**对客户端隐藏真实实现**，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。

我们发现没有，**代理模式说白了**就是做 **“方法包装”** 或做 **“方法增强”**。在**面向切面编程中，其实就是动态代理**的过程。比如 Spring 中，我们**自己不定义代理类**，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 **@Before、@After、@Around** 中的代码逻辑动态添加到代理中。

说到动态代理，又可以展开说，**Spring 中实现动态代理有两种**，一种是如果**我们的类定义了接口**，如 **UserService 接口和 UserServiceImpl 实现**，那么采用 **JDK 的动态代理**，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，**Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包**，性能还不错。

