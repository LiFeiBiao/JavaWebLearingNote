# 设计模式

https://mp.weixin.qq.com/s/yEAdDRijRav9bYgvR8a8QQ

## 认识

设计模式(Design Pattern)是前辈们经过相当长的一段时间的试验和错误总结出来的，是软件开发过程中面临的通用问题的解决方案。这些解决方案使用设计模式是为了**可重用代码**、**让代码更容易被他人理解、保证代码可靠性**。

## 分类

1）根据其目的
即模式是用来做什么的，可分为**创建型(Creational)**，**结构型(Structural)**和**行为型(Behavioral)**三种：
①创建型模式主要用于创建对象。
②结构型模式主要用于处理类或对象的组合。
③行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。

（2） 根据范围
即模式主要是**用于处理类之间关系还是处理对象之间的关系**，可分为类模式和对象模式两种：
类模式处理**类和子类**之间的关系，这些关系通过**继承建立**，在编译时刻就被确定下来，是**属于静态**的。

![image-20211020082222045](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20211020082222045.png)

## 优点

①可以提高程序员的**思维能力、编程能力和设计能力**。
②使程序设计更加标准化、代码编制更加工程化，**使软件开发效率大大提高，从而缩短软件的开发周期**。
③使设计的**代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强**。

（1）创建型模式：
**简单工厂**：**一个工厂类根据传入的参量决定创建出那一种产品类的实例。**
**工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。**
抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。
建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。
**单例模式：某个类只能有一个实例，提供一个全局的访问点。Spring 中的 Bean 默认都是单例的。**
原型模式：通过复制现有的实例来创建新的实例。
（2）**结构型模式**
外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。
桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。
组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。
装饰模式：动态的给对象添加新的功能。
**代理模式：为其他对象提供一个代理以便控制这个对象的访问。Spring AOP 功能的实现。**
**适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。**
亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。
（3）行为型模式
**模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。**
解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。
策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
状态模式：允许一个对象在其对象内部状态改变时改变它的行为。
**观察者模式：对象间的一对多的依赖关系。**
备忘录模式：在不破坏封装的前提下，保持对象的内部状态。
中介者模式：用一个中介对象来封装一系列的对象交互。
命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。

## 设计原则https://blog.csdn.net/yucaixiang/article/details/90239817

- **单一职责**

  一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。单一职责原则是实现**高内聚、低耦合**的指导方针

- **开闭原则**

  一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展

- **里氏替换原则**

  里氏代换原则(Liskov Substitution Principle, LSP)**：所有引用基类（父类）的地方必须能透明地使用其子类的对象。**

- **依赖倒置原则**

  **高层模块不应该依赖低层模块**，两者都应该**依赖其抽象**；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：**要面向接口编程，不要面向实现编程。**

- **接口原则**

  使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

- **迪米特法则**

  迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。

## spring中用到的设计模式

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring **AOP 功能的实现**。
- **单例设计模式** : Spring 中的 **Bean 默认都是单例的**。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **装饰器模式** : 我们的项目需要**连接多个数据库**，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们**可以根据客户的需求能够动态切换不同的数据源**。
- **观察者模式:** **Spring 事件驱动模型**就是观察者模式很经典的一个应用。
- **适配器模式** :**Spring AOP 的增强或通知(Advice)使用到了适配器模式**、spring MVC 中也是用到了适配器模式适配`Controller`。

## 简单工厂模式

简单地说，简单工厂模式通常就是这样，**一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象**

```java
public class FoodFactory {

    public static Food makeFood(String name) {
        if (name.equals("noodle")) {
            Food noodle = new LanZhouNoodle();
            noodle.addSpicy("more");
            return noodle;
        } else if (name.equals("chicken")) {
            Food chicken = new HuangMenChicken();
            chicken.addCondiment("potato");
            return chicken;
        } else {
            return null;
        }
    }
}
```

我们强调**职责单一**原则，**一个类只提供一种功能**，FoodFactory 的功能就是只要负责生产各种 Food。

## 工厂模式

简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂

第一步，我们**需要选取合适的工厂**，然后第二步基本上和简单工厂一样。

**核心在于，我们需要在第一步选好我们需要的工厂**。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。

## 抽象工厂模式

当涉及到**产品族**的时候，就需要引入抽象工厂模式了。

当涉及到这种产品族的问题的时候，就需要**抽象工厂模式**来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们**直接定义电脑工厂**，**每个电脑工厂负责生产所有的设备**，这样能保证肯定不存在兼容问题。

违反了**对修改关闭，对扩展开放**这个设计原则。

## 单例模式

饿汉式

```java
public class Singleton {
    // 首先，将 new Singleton() 堵死
    private Singleton() {};
    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建
    private static Singleton instance = new Singleton();

    public static Singleton getInstance() {
        return instance;
    }
}
```

**饱汗模式**容易出错

```java
public class Singleton {
    // 首先，也是先堵死 new Singleton() 这条路
    private Singleton() {}
    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的
    private static volatile Singleton instance = null;
    public static Singleton getInstance() {
        if (instance == null) {
            // 加锁
            synchronized (Singleton.class) {
                // 这一次判断也是必须的，不然会有并发问题
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
//双重检查，指的是两次检查 instance 是否为 null。
```

**嵌套类**

```java
public class Singleton3 {
    private Singleton3() {}
    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法的特性
    private static class Holder {
        private static Singleton3 instance = new Singleton3();
    }
    public static Singleton3 getInstance() {
        return Holder.instance;
    }
}
```

> 注意，很多人都会把这个**嵌套类**说成是**静态内部类**，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。

枚举很特殊，它**在类加载的时候会初始化里面的所有的实例**，而且 **JVM 保证了它们不会再被实例化**，所以它**天生就是单例**的。

## 代理设计模式

用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。

既然说是**代理**，那就要**对客户端隐藏真实实现**，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。

**静态代理**

```java
package com.atguigu.java;

/**
 * 静态代理举例
 * 特点：代理类和被代理类在编译期间，就确定下来了。
 */
interface ClothFactory{
    void produceCloth();
}

//代理类
class ProxyClothFactory implements ClothFactory{
    private ClothFactory factory;//用被代理类对象进行实例化
    public ProxyClothFactory(ClothFactory factory){
        this.factory = factory;
    }
    @Override
    public void produceCloth() {
        System.out.println("代理工厂做一些准备工作");
        factory.produceCloth();
        System.out.println("代理工厂做一些后续的收尾工作");
    }
}

//被代理类
class NikeClothFactory implements ClothFactory{
    @Override
    public void produceCloth() {
        System.out.println("Nike工厂生产一批运动服");
    }
}
public class StaticProxyTest {
    public static void main(String[] args) {
        //创建被代理类的对象
        ClothFactory nike = new NikeClothFactory();
        //创建代理类的对象
        ClothFactory proxyClothFactory = new ProxyClothFactory(nike);
        proxyClothFactory.produceCloth();

    }
}
```

**动态代理**

想实现动态代理需要解决的问题：

1. 如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象？
2. 当通过代理类的对象调用方法时，如何动态的去调用被代理类中的同名方法？

```java
package com.atguigu.java;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 动态代理的举例
 */
interface Human{
    String getBelief();
    void eat(String food);
}
//被代理类
class SuperMan implements Human{
    @Override
    public String getBelief() {
        return "I believe I can fly!";
    }
    @Override
    public void eat(String food) {
        System.out.println("我喜欢吃" + food);
    }
}

class HumanUtil{
    public void method1(){
        System.out.println("====================通用方法一====================");
    }
    public void method2(){
        System.out.println("====================通用方法二====================");
    }
}

/*
要想实现动态代理，需要解决的问题？
问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。
问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。
 */
class ProxyFactory{
    //调用此方法，返回一个代理类的对象。解决问题一
    public static Object getProxyInstance(Object obj){//obj:被代理类的对象
        MyInvocationHandler handler = new MyInvocationHandler();
        handler.bind(obj);
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);
    }
}
class MyInvocationHandler implements InvocationHandler{
    private Object obj;//需要使用被代理类的对象进行赋值
    public void bind(Object obj){
        this.obj = obj;
    }
    //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()
    //将被代理类要执行的方法a的功能就声明在invoke()中
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        HumanUtil util = new HumanUtil();
        util.method1();
        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
        //obj:被代理类的对象
        Object returnValue = method.invoke(obj,args);
        util.method2();
        //上述方法的返回值就作为当前类中的invoke()的返回值。
        return returnValue;
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        SuperMan superMan = new SuperMan();
        //proxyInstance:代理类的对象
        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);
        //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法
        String belief = proxyInstance.getBelief();
        System.out.println(belief);
        proxyInstance.eat("四川麻辣烫");
        System.out.println("*****************************");
        NikeClothFactory nikeClothFactory = new NikeClothFactory();
        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);
        proxyClothFactory.produceCloth();

    }
}
```

我们发现没有，**代理模式说白了**就是做 **“方法包装”** 或做 **“方法增强”**。在**面向切面编程中，其实就是动态代理**的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 **@Before、@After、@Around** 中的代码逻辑动态添加到代理中。

说到动态代理，又可以展开说，**Spring 中实现动态代理有两种**，一种是如果**我们的类定义了接口**，如 **UserService 接口和 UserServiceImpl 实现**，那么采用 **JDK 的动态代理**，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，**Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包**，性能还不错。

## 模板方法模式

在含有继承结构的代码中，模板方法模式是非常常用的。

```java
public abstract class AbstractTemplate {
    // 这就是模板方法
    public void templateMethod() {
        init();
        apply(); // 这个是重点
        end(); // 可以作为钩子方法
    }
    protected void init() {
        System.out.println("init 抽象层已经实现，子类也可以选择覆写");
    }
    // 留给子类实现
    protected abstract void apply();
    protected void end() {
    }
}
```

模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，**模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现**

```java
public class ConcreteTemplate extends AbstractTemplate {
    public void apply() {
        System.out.println("子类实现抽象方法 apply");
    }

    public void end() {
        System.out.println("我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了");
    }
}
```

## 观察者模式

观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，**观察者订阅自己关心的主题和主题有数据变化后通知观察者们。**

首先，**需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：**

```java
public class Subject {
    private List<Observer> observers = new ArrayList<Observer>();
    private int state;
    public int getState() {
        return state;
    }
    public void setState(int state) {
        this.state = state;
        // 数据已变更，通知观察者们
        notifyAllObservers();
    }
    // 注册观察者
    public void attach(Observer observer) {
        observers.add(observer);
    }
    // 通知观察者们
    public void notifyAllObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}
```

定义观察者接口：

```java
public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}
```

其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。

```java
public class BinaryObserver extends Observer {
    // 在构造方法中进行订阅主题
    public BinaryObserver(Subject subject) {
        this.subject = subject;
        // 通常在构造方法中将 this 发布出去的操作一定要小心
        this.subject.attach(this);
    }
    // 该方法由主题类在数据变更的时候进行调用
    @Override
    public void update() {
        String result = Integer.toBinaryString(subject.getState());
        System.out.println("订阅的数据发生变化，新的数据处理为二进制值为：" + result);
    }
}

public class HexaObserver extends Observer {
    public HexaObserver(Subject subject) {
        this.subject = subject;
        this.subject.attach(this);
    }
    @Override
    public void update() {
        String result = Integer.toHexString(subject.getState()).toUpperCase();
        System.out.println("订阅的数据发生变化，新的数据处理为十六进制值为：" + result);
    }
}
```

客户端使用也非常简单：

```java
public static void main(String[] args) {
    // 先定义一个主题
    Subject subject1 = new Subject();
    // 定义观察者
    new BinaryObserver(subject1);
    new HexaObserver(subject1);

    // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用
    subject.setState(11);
}
```

jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。

**实际生产过程中，观察者模式往往用消息中间件来实现**

核心的部分，那就是**一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。**

## 适配器模式

适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。

## 装饰者模式

**装饰者模式可以动态地给对象添加一些额外的属性或行为**。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 `InputStream`家族，`InputStream` 类下有 `FileInputStream` (读取文件)、`BufferedInputStream` (增加缓存,使读取文件速度大大提升)等子类都在不修改`InputStream` 代码的情况下扩展了它的功能。