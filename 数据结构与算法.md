# 数据结构与算法

## 树https://mp.weixin.qq.com/s/FXOEq-T7pDSlbwccW_2l_w

三种遍历方式，前序，中序，后序

### 二叉树

二叉树是一种特殊的树，二叉树中每个节点的度不大于 2 ，即它的每个节点最多只有两个分支，通常称二叉树节点的左右两个分支为左右子树。

#### 二叉查找树，二叉排序树

简单来说就是二叉树上所有节点的，左子树上的节点都小于根节点，右子树上所有节点的值都大于根节点。

**二叉查找树的查询复杂度取决于目标节点的深度**，因此当节点的深度比较大时，**最坏的查询效率是O(n)，其中n是树中的节点个数**

### （AVL）平衡二叉树

**最坏效率降低至O(log n)**

AVL 也叫平衡二叉查找树

天平两端的重量要差不多才能平衡，否则就会出现向一边倾斜的情况。把这个概念迁移到二叉树中来，根节点看作是天平的中点，左子树的高度放在天平左边，右子树的高度放在天平右边，**当左右子树的高度相差「不是特别多」，称为是平衡的二叉树**

在**二叉查找树中，任一节点对应的两棵子树的最大高度差为 1，这样的二叉查找树称为平衡二叉树**。其中左右子树的高度差也有个专业的叫法：**平衡因子。**

保持树平衡的目的是可以控制**查找、插入和删除**在**平均和最坏情况下的时间复杂度都是O(log n)**，相比普通二叉树最坏情况的时间复杂度是 O(n) 

### **B树**

一个 m 阶的B树是一个有以下属性的树

1. 每一个节点最多有 m 个子节点
2. 每一个非叶子节点（除根节点）最少有 ⌈m/2⌉ 个子节点，⌈m/2⌉表示向上取整。
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 **k 个子节点的非叶子节点拥有 k − 1 个键**
5. **所有的叶子节点都在同一层**

- B树是**所有节点的平衡因子均等于0的多路查找树**（AVL树是平衡因子不大于 1 的二路查找树）。
- B 树**节点可以保存多个数据**，使得 B 树可以不用像 AVL 树那样为了保持平衡频繁的旋转节点。
- B树的**多路的特性，降低了树的高度**，所以B树相比于平衡二叉树显得矮胖很多。
- B树**非常适合保存在磁盘中的数据读取**，因为每次读取都会有一次磁盘IO，高度降低减少了磁盘IO的次数。

**B树常用于实现数据库索引**，典型的实现，MongoDB索引用B树实现，MySQL的Innodb 存储引擎用B+树存放索引。

### B+树https://mp.weixin.qq.com/s/FXOEq-T7pDSlbwccW_2l_w

- **每个结点至多有m个子女**;
- 非根节点关键值个数范围：⌈m/2⌉ - 1 <= k <= m-1
- **相邻叶子节点是通过指针连起来的，并且是关键字大小排序的。**
  - **B+树和B树的区别**
    - B-树内部节点是保存数据的**;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。**
    - B+树**相邻的叶子节点之间是通过链表指针连起来的**，B-树却不是。
    - 查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束
    - B-树中**任何一个关键字出现且只出现在一个结点中**，而B+树**可以出现多次。**

### 红黑树

红黑树中**每个结点都被标记了红黑属性**，红黑树除了有普通的「二叉查找树」特性之外，还有以下的特征：

1. **节点是红色或黑色**。
2. **根是黑色**。
3. **所有叶子都是黑色（叶子是NIL节点）**。
4. **每个红色节点必须有两个黑色的子节点。**（从**每个叶子到根的所有路径上不能有两个连续的红色节点**。）
5. 从任一节点到其每个叶子的所有简单路径都包含**相同数目的黑色节点**。

**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。**

最坏情况下的查找、插入、删除操作的时间复杂度**不超过O(log n)**，并且有较高的插入和删除效率。

**与AVL相比**

- 插入和删除操作，一般认为红黑树的删除和插入会比 AVL 树更快。因为，**红黑树不像 AVL 树那样严格的要求平衡因子小于等于**1，这就**减少了为了达到平衡而进行的旋转操作次数**，可以说是**牺牲严格平衡性来换取更快的插入和删除时间**。
- 红黑树不要求有不严格的平衡性控制，**但是红黑树的特点，使得任何不平衡都会在三次旋转之内解决**。而 AVL 树如果不平衡，并不会控制旋转操作次数，旋转直到平衡为止。
- **查找操作，AVL树的效率更高。因为 AVL 树设计比红黑树更加平衡**，不会出现平衡因子超过 1 的情况，**减少了树的平均搜索长**度。

### Trie树（前缀树或字典树）

利用**字符串前缀来查找指定的字符串**，缩短查找时间提高查询效率，主要用于字符串的快速查找和匹配。

Trie的核心思想是**空间换时间**，有 3 个基本性质：

1. **根节点不包含字符，除根节点外每一个节点都只包含一个字符**。
2. **从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串**。
3. **每个节点的所有子节点包含的字符都不相同。**

**Trie树建立和查询是可以同步进行的**，可以在还没建立出完成的 Trie 树之前就找到目标数据，而如果**用 Hash 表等结构存储是需要先建立完成表才能开始查询**，这也是 Trie 树查询速度快的原因

**Trie树还用于搜索引擎的关键词提示功能**

## 线性表

### **数组**

由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

### **链表**

因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

### 跳表https://mp.weixin.qq.com/s/Ok0laJMn4_OzL-LxPTHawQ

**Redis跳表(zset)**

**跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构**，跳表是一个**随机化的数据结构**，实质就是一种**可以进行二分查找的有序链表**。**跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找**。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。

**以空间换时间**，我们在上面加一层索引，让部分节点在上层能够直接定位到，这样链表的查询时间近乎减少一半

**跳表就能让链表拥有近乎的接近二分查找的效率的一种数据结构**，其原理依然是给上面加若干层索引，优化查找速度

**首先在最高级索引上查找最后一个小于当前查找元素的位置**，**然后再跳到次高级索引继续查找**，**直到跳到最底层为止**，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)

## 排序算法https://mp.weixin.qq.com/s/2u4lV3zn-LFxvihM9PFF-g

![image-20211018141759001](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20211018141759001.png)

### 冒泡排序

```java
for (int i=0;i<numbers.length-1;i++){
    //内层循环控制到达位置
    for (int j=0;j<numbers.length-1-i;j++){
        //比较前面的元素比后面元素大交换，同理也可以比较小
        if (numbers[j]>numbers[j+1]){
            int temp=numbers[j];
            numbers[j]=numbers[j+1];
            numbers[j+1]=temp;
        }
    }
}
```

冒泡排序是最容易实现的排序, **最坏的情况是每次都需要交换**, 共需遍历并交换将近n²/2次, **时间复杂度为O(n²)**. **最佳的情况是内循环遍历一次后发现排序是对的**, 因此退出循环, **时间复杂度为O(n)**. 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中**只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).**

### 冒泡排序

```
    public void bubbleSort(int[] arr) {
        if (arr == null) {
            return;
        }
        boolean flag;
        for (int i = arr.length - 1; i > 0; i--) {
            flag = false;
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = true;
                }
            }
            if (!flag) {
                return;
            }
        }
    }
```

### 插入排序

```
    public void insertSort(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            int tmp = arr[i];
            int j = i;
            for (; j > 0 && tmp < arr[j - 1]; j--) {
                arr[j] = arr[j - 1];
            }
            arr[j] = tmp;
        }
    }
```

### 选择排序

```
    public void selectionSort(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] > arr[j]) {
                    int tmp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = tmp;
                }
            }
        }
    }
```

### 基数排序

在基数排序中，因为没有比较操作，所以在时间复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d * (n + r))。d 为位数，r 为基数，n 为原数组个数。

 [![img](https://camo.githubusercontent.com/ad561bf4182591c13e85b527d04a86d10a0f91e2f5fde13c866a9d1fdae2fbd3/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939706257466e5a584d794d4445344c6d4e75596d78765a334d75593239744c324a73623263764d5449314d6a6b784d4338794d4445344d446b764d5449314d6a6b784d4330794d4445344d446b784d7a45784d4459794f5459344e6930304d4455304d6a6b354e6a6b756347356e3f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67)](https://camo.githubusercontent.com/ad561bf4182591c13e85b527d04a86d10a0f91e2f5fde13c866a9d1fdae2fbd3/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939706257466e5a584d794d4445344c6d4e75596d78765a334d75593239744c324a73623263764d5449314d6a6b784d4338794d4445344d446b764d5449314d6a6b784d4330794d4445344d446b784d7a45784d4459794f5459344e6930304d4455304d6a6b354e6a6b756347356e3f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67)

### 快速排序

```
    public void quickSort(int[] arr) {
        if (arr == null) {
            return;
        }
        quickSortHelper(arr, 0, arr.length - 1);
    }
    private void quickSortHelper(int[] arr, int left, int right) {
        if (left > right) {
            return;
        }
        int tmp = arr[left];
        int i = left;
        int j = right;
        while (i < j) {
            //j先走，最终循环终止时，j停留的位置就是arr[left]的正确位置
            //改为i<=j，则会进入死循环，[1,5,5,5,5]->[1] 5 [5,5,5]->[5,5,5]，会死循环
            while (i < j && arr[j] >= tmp) {
                j--;
            }
            while (i < j && arr[i] <= tmp) {
                i++;
            }
            if (i < j) {
                int tmp1 = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp1;
            } else {
                break;
            }
        }

        //当循环终止的时候，i=j，因为是j先走的，j所在位置的值小于arr[left]，交换arr[j]和arr[left]
        arr[left] = arr[j];
        arr[j] = tmp;

        quickSortHelper(arr, left, j - 1);
        quickSortHelper(arr, j + 1, right);
    }
```

### 归并排序

[![归并排序图](https://camo.githubusercontent.com/2a3a77edbad8320d1c52782f27ce402d8dde27fa8f68ff6d2941788121d84853/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f313032343535352f3230313631322f313032343535352d32303136313231383136333132303135312d3435323238333735302e706e67)

```
public class MergeSort {
    public void mergeSort(int[] arr) {
        if (arr == null || arr.length == 0) {
            return;
        }
        //辅助数组
        int[] tmpArr = new int[arr.length];
        mergeSort(arr, tmpArr, 0, arr.length - 1);
    }

    private void mergeSort(int[] arr, int[] tmpArr, int left, int right) {
        if (left < right) {
            int mid = (left + right) >> 1;
            mergeSort(arr, tmpArr, left, mid);
            mergeSort(arr, tmpArr, mid + 1, right);
            merge(arr, tmpArr, left, mid, right);
        }
    }

    private void merge(int[] arr, int[] tmpArr, int left, int mid, int right) {
        int i = left;
        int j = mid + 1;
        int tmpIndex = left;
        while (i <= mid && j <= right) {
            if (arr[i] < arr[j]) {
                tmpArr[tmpIndex++] = arr[i];
                i++;
            } else {
                tmpArr[tmpIndex++] = arr[j];
                j++;
            }
        }

        while (i <= mid) {
            tmpArr[tmpIndex++] = arr[i++];
        }

        while (j <= right) {
            tmpArr[tmpIndex++] = arr[j++];
        }

        for (int m = left; m <= right; m++) {
            arr[m] = tmpArr[m];
        }
    }
}
```

### 堆排序

堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

[![img](https://camo.githubusercontent.com/d41a937067e1fe7b9ed798e126db49c23bb29ec47d8aec5fb68e34f3df00de39/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f3230313530333132323132353135303734)](https://camo.githubusercontent.com/d41a937067e1fe7b9ed798e126db49c23bb29ec47d8aec5fb68e34f3df00de39/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f3230313530333132323132353135303734)

**Top大问题**解决思路：使用一个固定大小的**最小堆**，当堆满后，每次添加数据的时候与堆顶元素比较，若小于堆顶元素，则舍弃，若大于堆顶元素，则删除堆顶元素，添加新增元素，对堆进行重新排序。

对于n个数，取Top m个数，时间复杂度为O(nlogm)，这样在n较大情况下，是优于nlogn（其他排序算法）的时间复杂度的。

PriorityQueue 是一种基于优先级堆的优先级队列。每次从队列中取出的是具有最高优先权的元素。如果不提供Comparator的话，优先队列中元素默认按自然顺序排列，也就是数字默认是小的在队列头。优先级队列用数组实现，但是数组大小可以动态增加，容量无限。

```
//找出前k个最大数，采用小顶堆实现
public static int[] findKMax(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(k);//队列默认自然顺序排列，小顶堆，不必重写compare

    for (int num : nums) {
        if (pq.size() < k) {
            pq.offer(num);
        } else if (pq.peek() < num) {//如果堆顶元素 < 新数，则删除堆顶，加入新数入堆
            pq.poll();
            pq.offer(num);
        }
    }

    int[] result = new int[k];
    for (int i = 0; i < k&&!pq.isEmpty(); i++) {
        result[i] = pq.poll();
    }
    return result;
}
```



## 搜索算法

### 线性搜索

时间复杂度O(n)

### 二分查找

递归实现

```java
int binarySearch(int arr[], int l, int r, int x)
    {
        if (r >= l) {
            int mid = l + (r - l) / 2;
            // If the element is present at the
            // middle itself
            if (arr[mid] == x)
                return mid;
            // If element is smaller than mid, then
            // it can only be present in left subarray
            if (arr[mid] > x)
                return binarySearch(arr, l, mid - 1, x);
            // Else the element can only be present
            // in right subarray
            return binarySearch(arr, mid + 1, r, x);
        }
        // We reach here when element is not present
        // in array
        return -1;
    }
```

迭代实现

```java
int binarySearch(int arr[], int x)
    {
        int l = 0, r = arr.length - 1;
        while (l <= r) {
            int m = l + (r - l) / 2;
            // Check if x is present at mid
            if (arr[m] == x)
                return m;
            // If x greater, ignore left half
            if (arr[m] < x)
                l = m + 1;
            // If x is smaller, ignore right half
            else
                r = m - 1;
        }
        // if we reach here, then element was
        // not present
        return -1;
    }
```

**辅助空间：**在迭代实现的情况下为 O(1)。在递归实现的情况下，**O(Logn) 递归调用堆栈空间。**

### 跳转查找

与[Binary Search](http://geeksquiz.com/binary-search/)一样，Jump Search 是一种用于排序数组的搜索算法。基本思想是通过固定步骤向前跳跃或跳过某些元素而不是搜索所有元素来检查更少的元素（比[线性搜索](https://www.geeksforgeeks.org/analysis-of-algorithms-set-2-asymptotic-analysis/)）

m = √n 时，函数 ((n/m) + m-1) 的值将最小。因此，**最佳步长为 m =** **√n。**

```java
public static int jumpSearch(int[] arr, int x)
    {
        int n = arr.length;
        // Finding block size to be jumped
        int step = (int)Math.floor(Math.sqrt(n));
        // Finding the block where element is
        // present (if it is present)
        int prev = 0;
        while (arr[Math.min(step, n)-1] < x)
        {
            prev = step;
            step += (int)Math.floor(Math.sqrt(n));
            if (prev >= n)
                return -1;
        }
        // Doing a linear search for x in block
        // beginning with prev.
        while (arr[prev] < x)
        {
            prev++;
            // If we reached next block or end of
            // array, element is not present.
            if (prev == Math.min(step, n))
                return -1;
        }
        // If element is found
        if (arr[prev] == x)
            return prev;
        return -1;
    }
```

**时间复杂度：O(√n)** 
**辅助空间：O(1)**

### 指数搜索

1. 查找元素所在的范围
2. 在上面找到的范围内进行二分搜索。

**时间复杂度：** O(Log n) 
**辅助空间：**上述二分搜索的实现是递归的，需要 O(Log n) 空间。使用迭代二分搜索，我们只需要 O(1) 空间。

### 插值搜索

```
让我们假设数组的元素是线性分布的。 

线的一般方程：y = m*x + c。
y 是数组中的值，x 是它的索引。

现在将 lo、hi 和 x 的值放入等式中
arr[hi] = m*hi+c ----(1)
arr[lo] = m*lo+c ----(2)
x = m*pos + c ----(3)

m = (arr[hi] - arr[lo] )/ (hi - lo)

从 (3) 中减去 eqxn (2)
x - arr[lo] = m * (pos - lo)
lo + (x - arr[lo])/m = pos
pos = lo + (x - arr[lo]) *(hi - lo)/(arr[hi] - arr[lo])
```

### 三元查找

