# Java数组

## 数组

数组属于引用数据类型；多个相同数据类型的数据按一定顺序排列的集合，并使用一个名字命名

- 数组名，元素，角标，下标，索引，数组的长度，元素个数
- 数组是有序排列的
- 数组属于引用数据类型的变量，既可以是基本数据类型，也可以是引用数据类型
- 在内存中开辟一块连续的存储空间
- 数组长度一旦确定不可以修改

## 数组的分类

- 按照维数：一维数组，二维数组。。。
- 按照数组元素的类型：基本数据类型元素的数组，引用数据类型元素的数组

### 一维数组的使用

- 一维数组的声明和初始化

  ```java
  int[] a1;//数组声明
  //数组静态初始化,数组的初始化和数组元素的赋值操作同时进行
  a1 = new int[]{100,200,300,400};
  //数组的动态初始化，数组的初始化和数组元素的赋值操作分时进行
  String[] name = new String[5];
  //数组一旦初始化，数组长度就确定了
  ```

- 如何调用数组的指定位置的元素

  数组的角标（或索引），从0开始到数组的长度-1

- 如何**获取**数组的**长度**

  属性：length

- 如何**遍历**数组

  利用循环结构遍历数组。 

- 数组元素的默认初始值

  1. 数组元素是整型：0
  2. 数组元素是浮点型：0.0
  3. 数组元素是char型：0或‘\u0000’而不是'0'
  4. 数组元素是Boolean型：false
  5. 数组元素是引用数据类型：null

- 数组的内存解析

  #### 栈：存放局部变量

  #### 堆：new出来的结构，对象和数组

  #### 方法区：常量池和静态域

### 二维数组的使用：

- 理解：二维数组可以看作一个一维数组array1又作为另一个一维数组array2的元素而存在

- 从数组底层的运行机制来看，没有多维数组

  ```java
  //静态声明和初始化
  int[][] arr1 = new int[][]{{1,2,3},{4,5},{7,8,9}};
  //动态初始化1
  String[][] arr2 = new String[3][2];
  //外层元素的初始化值：地址值
  //内层元素的初始化值：与一维数组初始化情况相同
  
  //动态初始化2
  String[][] arr3 = new String[3][];
  //外层元素的初始化值：null
  //内层元素的初始化值：不能调用，否则报错
  ```


# Java面向对象

## 三条主线

1. Java类和类的成员：**属性，方法，构造器，代码块，内部类**
2. 面向对象的三大特征：**封装，继承，多态（抽象性）**
3. 其他关键字：**this,super,static,final,abstract,interface,package,import**

## 面向对象和面向过程的区别

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出**低耦合**的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

## 面向对象两个要素 

1. **类**：对一类事物的描述，是抽象的概念上的定义
2. **对象**，是实际存在的该类事物的每个个体，因而也成为实例（instance）
3. 面向对象程序设计的重点是**类的设计**，设计类，就是设计类的成员。

### Java类和类的成员

1. **属性**：对应类中的成员变量
2. **方法**：对应类中的成员方法（函数）
3. **类的实例化就是创建对象**

### 类和对象的使用（面向对象思想落地实现）

1. 创建类，设计类的成员
2. 创建类的对象
3. 通过“对象.属性”或"对象.方法"调用对象结构

![image-20210725093122954](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210725093122954.png)

#### 匿名对象的使用

1. 格式：**new 对象名（）.方法名或属性名**
2. 理解：创建的对象，没有显示的赋给一个变量名，即为匿名对象
3. 特征：**匿名对象只能使用一次**

#### 理解"万事万物皆对象"

1. 在java语言范畴中，我们都将功能，结构等封装到类中，通过类的实例化，来调用具体的功能结构
   - Scanner，String，等
   - 文件：File
   - 网络资源：URL
2. 涉及到Java语言与前端Html，后端的数据交互时，前后端的结构Java层面交互时，都体现为类，对象

### 类中属性（类的内部成员之一）

1. 属性（成员变量）和局部变量
   - 相同点：
     1. 定义变量的格式：**数据类型 变量名 = 变量值**
     2. **先声明，后使用**
     3. 变量都有其对应的作用域
   - 不同点：
     1. <u>在类中声明的位置不同</u>，**属性（成员变量）**直接定义在类的一对{}中；**局部变量**声明在方法内，代码块内，构造器形参，构造器内部的变量
     2. <u>关于权限修饰符</u>，**属性（成员变量）**可以在声明属性时，指明其权限，使用权限修饰符。**局部变量**不使用权限修饰符
     3. **常用权限修饰符**：**private,public,缺省，protected**
     4. **默认初始化值**：**属性：**类的属性，根据其类型，都有默认初始化值；**局部变量：**<u>没有默认初始化值，定义时必须赋值</u>，形参在方法调用时赋值即可。
     5. 内存中加载的位置：**属性（成员变量）**：加载到**堆空间**中，**局部变量**在**栈**中

### 类中方法（类的内部成员之二）

#### 方法：描述类该有的功能

1. 方法的声明：权限修饰符  返回值类型  函数名（形参列表）{

   ​                          						方法体

   ​						}

2. 说明：

   1. 关于权限修饰符，默认方法的权限修饰符先都使用public
   2. 返回值类型：有返回值和无返回值
      - **有返回值，必须在方法声明时，指定返回值的类型**，同时在方法中需使用return返回指定数据类型的变量或常量；如没有返回值，则在方法声明时使用void来表示。

3. 方法名：属于标识符，命名规范，见名知意

4. 形参列表：**方法可以声明0个，1个，或者多个**。格式：数据类型1 形参1，数据类型2，形参2，……

5. 方法体：方法功能的体现

6. 方法的使用中，可以调用当前类的属性和方法

#### return关键字的使用 

1. 使用范围：使用在方法体中
2. **作用**：**结束方法，针对有返回值的方法**，使用**”return数据“**返回所需数据
3. 注意点：return关键字后面不可以声明执行语句

#### 方法的重载和重写

##### 重载

1. 定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参**数个数或者参数类型不同**即可
   - "两同一不同"：**同一个类，相同方法名**；参数列表不同，**参数个数不同，参数类型不同**
2. 举类：Array类中重载的sort()/binarySearch()
3. 判断是否重载
   - **跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系**

##### 重写

重写发生在**运行期**，是**子类对父类的允许访问的方法的实现过程进行重新编写**。

1. **返回值类型、方法名、参数列表**必须相同，**抛出的异常范围小于等于父类，访问修饰符范围大于等于父类**。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变

**方法的重写要遵循“两同两小一大”**

- “两同”即**方法名相同、形参列表**相同；
- “两小”指的是**子类方法返回值类型应比父类方法返回值类型更小或相等**，子类方法声明**抛出的异常**类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是**子类方法的访问权限应比父类方法的访问权限更大或相等**。

1. ![image-20210909224003227](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210909224003227.png)

#### 构造器(类的内部成员之三)

1. **构造器的作用**

   - **创建对象**
   - **初始化对象的属性**

2. **说明**

   - 如果没有显示的定义类的构造器，则系统默认提供一个空参构造器
   - 定义构造器的格式：**权限修饰符  类名（参数列表）{}** 
   - 一个类中定义的多个构造器，彼此之间构成**重载**
   - 一旦显示的定义了类的构造器，系统就不再提供默认的空参构造器
   - 一个类中至少要有一个构造器

3. #### **属性赋值的先后顺序**

   - ①**默认初始化值**
   - ②**显示初始化/**⑤**代码块中赋值**
   - ③**构造器中赋值**
   - ④通过“**对象.方法”和“对象.属性”**进行赋值
   - 操作顺序① - ②/⑤ - ③ - ④ 

#### 递归方法的使用

1. 递归方法：一个方法体内调用它自身
2. 方法递归包含了隐式的循环，它会重复执行某行代码，但这种重复执行无需循环控制，递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

## 内存解析

1. **堆(Heap)** ,此内存区域的唯一目的就是**存放对象实例**,几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。
2. **栈(Stack)** ,是指虚拟机栈。虚拟机栈用于**存储局部变量**等。局部变量表存放了编译期可知长度的各种**基本数据类型(**boolean, byte.char、 short、 int、 float、 long、double) 、**对象引用**(reference类型,它不等同于对象本身,是对象在堆内存的首地址)。**方法执行完, 自动释放。**
3. **方法区(Method Area)** ,用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码等**数据。
4. **编译完源程序以后，生成一个或多个字节码文件，使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行，**意味着将字节码文件对应的类加载到内存中，涉及到内存解析

**内存解析的说明**

1. 引用类型的变量，只能存储两类值：**null**或**地址值** 	（含变量的类型 ）

### 可变个数的形参

1. jdk5.0新增的内容
2. 具体使用
   - 可变个数形参的格式：**数据类型... 变量名**
   - 当调用可变个数形参的方法时，传入的参数个数可以时0个，1个，或者多个
3. 可变个数形参的方法与本类中方法名相同，**形参不同的方法之间构成重载**
4. 可变个数形参的方法与本类中方法名相同，形参类型也相同的**数组**之间不构成重载，换句话说“二者不能同时存在”
5. 可变个数形参在方法的形参中，**必须声明在末尾**
6. 可变个数形参在方法的形参中，**最多只能声明一个可变形参。**

### 方法参数的值传递机制

1. 形参:方法声明时的参数
2. 实参：方法调用时实际传给形参的参数值
3. 值传递机制
   - 如果参数时基本数据类型，此时赋值（实参赋给形参）的是（实参）所保存的数据值
   - 如果参数是引用数据类型，此时赋值（实参赋给形参）的是实参所保存的数据的地址值

### 深拷贝和浅拷贝

1. **浅拷贝**：**对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝**，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝
3. ![image-20210909224535441](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210909224535441.png)

## 封装与隐藏

1. 问题的引入
   - **当创建一个类的对象以后，可以通过“对象.属性”的方式，对对象的属性进行赋值，受属性的数据类型和存储范围的制约，除此之外，没有其他制约条件**。在实际问题中，往往需要给属性添加额外的限制条件，这个条件不能在属性声明时体现 ，只能通过方法进行制约条件的添加（比如**set方法**），同时，避免用户在使用“**对象.属性**”对属性进行赋值。则需要将属性声明为私有的（**private**）。
   - 此时针对于属性就体现了**封装性**
2. 封装性的体现：将类的属性（xxx)私有化（private），同时，提供公共的（public）方法来获取（getxxx）和设置（setxxx）此属性的值
3. 拓展：封装性的体现：1、如上；2、**不对外暴露的私有的方法**；3、**单例模式**

#### 为什么需要封装，封装的作用和含义？

1. 程序设计追求**“高内聚,低耦合**”。>**高内聚**:类的内部数据操作细节自己完成,不允许外部干涉;>**低耦合**:仅对外暴露少量的方法用于使用。
2. **隐藏对象内部的复杂性,只对外公开简单的接口**。便于外界调用,从而**揚高系统的可扩展性、可维护性**。通俗的说,把该隐藏的隐藏起来,该暴露的暴露出来。这就是封装性的设计思想。

#### 封装性的体现，需要权限修饰符配合

1. Java规定的四种权限关键字（从小到大排列）：**private，缺省，protected，public**
2. 对于**class**的权限修饰只可以用**public和defaul(缺省)**。
3. **public类**可以在**任意地方**被访问。**default类**只可以被**同一个包内部的类**访问。
4. 可以用来修饰类和类的内部结构：**属性，方法，构造器，内部类**

![image-20210727092118202](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210727092118202.png)

Java提供了**四种权限修饰符来修饰类和类的内部结构**，体现类和类的内部结构在被调用时可见性的大小

#### JavaBean

1. JavaBean是一种**lava语言写成的可重用组件**
2. 所谓JavaBean,是指符合如下标准的Java类:
   - **类是公共的**
   - **有一个无参的公共的构造器**
   - **有属性,且有对应的get, set方法**
3. 用户可以使用JavaBean将**功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包,**并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean, applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能,而不用关心任何改变。

## 继承性

1. 好处
   - 减少代码冗余，提高代码复用性
   - 便于功能的扩展
   - 为之后多态性的使用，提供了前提
2. 格式
   - class A extends B{}
   - A子类，派生类 subclass
   - B父类，超类，基类supercla
   - 体现：一旦A继承B后，子类A获取了父类B声明的结构：方法，属性；特别的，父类中声明的私有（private）的属性和方法，子类继承之后，仍然获取了父类中私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。
   - 子类继承父类以后，可以声明定义自己特有的方法和属性
   - 子类和父类的关系，不同于子集和集合的关系
3. 规定：
   - 一个类可以被多个子类继承
   - 一个类只能有一个父类
   - 子父类是相对的概念。
   - 子类直接继承的父类，称为直接父类，间接继承的父类称为间接父类
   - 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法
   - **同名同类型属性不会被覆盖**
4. object类
   - 如果没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类
   - 所有的类都直接或间接继承于Object类
   - 所有Java类都具有java.lang.Object类声明的功能

### 方法的重写（override,overwrite)

1. 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
2. 应用：重写以后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法
3. 重写的规定：
   - **方法的声明**：权限修饰符  返回值类型  方法名（参数列表）throws	异常类型{方法体}
   - 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
   - 子类重写的方法的**方法名和形参列表**与父类被重写的方法的方法名和形参列表**相同**
   - 子类重写的方法的**权限修饰符不小于**父类被重写的方法的权限修饰符
   - **特殊情况**：子类中不能重写父类中声明为**private权限**的方法
   - 返回值类型：
     1. 父类被重写的方法的返回值类型是**void**，则子类重写的方法的返回值类型也只能是**void**
     2. 父类被重写的方法的返回值类型是**A类**，则子类重写的方法的返回值类型可以是**A类或A类的子类**
     3. 父类被重写的方法的返回值类型是**基本数据类型**，则子类重写的方法的返回值类型必须是相同的基本数据类型
     4. 子类重写方法抛出的**异常类型不大于**父类被重写的方法抛出的异常类型
   - 子类和父类中同名同参数的方法要么都声明为**非static的（考虑重写）**，要么都声明为static的（不是重写）。

### 子类对象实例化的全过程

1. 从结果上看（继承性）
   - 子类继承父类以后，就获取了父类中声明的属性和方法
   - 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
2. 从过程上看:
   - 通过子类构造器创建子类对象时，一定会直接或间接的调用父类的构造器，进而调用父类的父类的构造器，直到调用java.lang.Object类中空参的构造器为止，因为加载过所有的父类结构，才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
3. 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new()的子类对象

## 多态性

1. 可以理解为一个事物得多种形态
   - **对象的多态性**：**父类的引用指向子类的对象**（或者子类的对象赋给父类的引用)
   - 多态的使用;**当调用子父类同名同参数的方法时**，实际**执行的是子类重写父类的方法**--------**虚拟方法调用**
2. 多态的使用，虚拟方法调用
   - 有了对象的多态性后，在**编译期，只能调用父类中声明的方法**，但**在运行期，实际执行的是子类重写父类的方法**
   - **编译：看左边，执行：看右边**
3. 多态性的使用前提：
   - **类的继承关系**
   - **方法的重写**
4. 对象的多态性，只适用于方法，不适用属性**（编译和运行都看左边）**
5. **虚拟方法调用**
   - 子类中定义了与父类**同名同参数**的方法,在多态情况下,将此时父类的方法称为**虚拟方法**,父类根据赋给它的不同子类对象,动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
   - 编译时类型和运行时类型
     - **动态绑定**

#### 从编译和运行的角度看方法的重载和重写

- **重载,**提指允许存在多个同名方法,而这些方法的参数不同。编译器根据方法不同的参数表,对同名方法的名称做修饰。对于编译器而言,这些同名方法就成了不同的方法。**它们的调用地址在编译期就绑定了**。Java的重载是可以包括父类和子类的,即子类可以重载父类的同名不同参数的方法。所以:对于重载而言,在方法调用之前,编译器就已经确定了所要调用的方法,,这称为**“早绑定”或“静态绑定**”而对于**多态**,**只有等到方法调用的那一刻,编译器才会确定所要调用的具体方法**,这称为**“晚绑定”或“动态绑定”**引用一句Bruce Eckel的话: “**不要犯傻,如果它不是晚绑定,它就不是多态**。

7. 为什么**this()或super()**调用语句只能出现在构造器中的第一句？
   - 无论通过哪个构造器创建子类对象，需要保证先初始化父类
   - 目的：当子类继承父类后，“继承”父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化
8. **向下转型**
   - 有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。
   - **如何才能调用子类特有的属性和方法**？
   - 使用强制类型转换符（）**向下转型**
   - 使用强转时，可能出现Class'CastException的异常
9. 练习：
   - 1·若子类重写了父类方法,就意味着子类里定义的方法彻底覆盖了父类里的同名方法,系统将不可能把父类里的方法转移到子类中:**编译看左边,运行看右边**
   - 2.对于实例变量则不存在这样的现象,即使子类里定义了与父类完全相同的实例变量,这个实例变量依然不可能覆盖父类中定义的实例变量:**编译运行都看左边**

## java关键字

#### this关键字的使用

1. this可以用来修饰**属性，方法，构造器**
2. this修饰属性和方法，this理解为**当前对象**,通常情况下选择二省略“this”，特殊情况下，如果方法的形参和类的属性同名时，必须显式的使用“this.属性”的方式，表明此变量是属性，不是形参。
3. this.age=age this表示该类的一个对象，this.age成员变量
4. this(age)；该类的构造器
   - 在类的构造器中，可以显式的使用“this（参数列表）”方式，调用本类中指定的其他构造器
   - 构造器中不能使用“this（参数列表）”方式调用自己
   - 如果一个类中有n个构造器，则最多有n-1个构造器中使用了“this（参数列表）”
   - 规定：“this（参数列表）”必须声明在当前构造器的首行
   - 构造器内部，最多只能声明一个“this（参数列表）”，调用其他构造器

#### Static关键字的使用

1. static：静态的

2. static用来修饰：**属性，方法，代码块，内部类**

3. 修饰属性

   - **静态变量或者类变量**

   - 属性按是否使用static修饰：分为：静态属性和非静态属性（实例变量）

   - 实例变量：当创建了类的对象，每个对象都独立的拥有一套类中的非静态属性，修改其中一个对象中的非静态变量，不会导致其他对象中相同的属性值的修改

   - 静态变量：创建了类的多个对象，多个对象共享同一个静态变量，当通过一个对象修改静态变量时，会导致其他对象调用此静态变量时，值是修改过的。

   - 修饰属性的其他说明：

     - 静态变量随着类的加载而加载，可以通过**“类名.属性”**的方式进行调用

     - 静态变量加载早于对象的创建

     - 由于类只会加载一次，则静态变量在内存中只会存在一份，存在方法区的静态域中

     - 静态属性举例;System.out;Math.PI

       |      | 类变量 | 实例变量 |
       | :--: | :----: | :------: |
       |  类  |  yes   |    no    |
       | 对象 |  yes   |   yes    |

4. **使用static修饰的方法，静态方法**

   - 随着类的加载而加载，可以通过**“类名.方法”**的方式进行调用

   - 静态方法中只能调用静态的方法或属性

   - 对于非静态方法可以调用非静态和静态的属性和方法

   - |      | 静态方法（类） | 非静态方法(对象) |
     | :--: | :------------: | :--------------: |
     |  类  |      yes       |        no        |
     | 对象 |      yes       |       yes        |

     

5. **static注意点**

   - 在静态方法内，不能使用**this和super**关键字
   - 从生命周期的角度去理解静态属性和静态方法

6. 开发中如何确定**一个属性是否要声明为static**？

   - 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
   - 类中的常量也常常声明为static

7. 开发中，如何确定一个**方法是否要声明为static的？**

   - 操作静态属性的方法，通常设置为static的
   - 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections

#### package，import关键字的使用

1. **package关键字的使用**
   - 为了更好的实现项目中类的管理，提供包的概念
   - 使用**package**声明**类或接口**所属包，声明在源文件的**首行**
   - 包名：属于标识符，全部小写，规范“见名知意”
   - 每“。”一次，就代表一层文件目录
   - 同一个包下，不可以命名同名的接口和类
2. **import关键字的使用**
   - 在源文件中显示的使用import结构导入指定包下的类，接口
   - 声明在包和类的声明之间
   - 如果需要导入多个结构，则并列写出即可
   - 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
   - 如果使用的类或接口是本包下定义的，可以省略import
   - 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。
   - import  static：导入指定类或接口中的静态结构：属性，方法

![image-20210727132402187](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210727132402187.png)

#### super关键字

1. super理解为：父类的
2. super可以用来调用**属性，方法，构造器**
3. 使用：
   - 可以在子类的方法或构造器中，通过使用“super.属性”和“super.方法”的方式，显式的调用父类中声明的属性或方法，通常情况下，习惯省略“super”
   - 特殊情况：当子类中定义了和父类中同名的属性时，要想再子类中调用父类中的同名属性，必须显式的使用“super.属性”的方式，表明调用的是父类中声明的属性
   - 特殊情况，当子类中重写了父类的方法后，想在子类中调用父类中被重写的方法时，必须显式的使用“super.方法”的方式，表明调用的是父类中声明的方法
4. **super调用构造器**
   - 可以在子类的构造器中显式的使用“super（形参列表）”的方式，调用父类中声明的指定的构造器
   - “super（形参列表）”的使用，必须声明在子类构造器方法体的首行
   - 在类的构造器中，针对于“this（形参列表）”或“super（形参列表）”只能二选一，不能同时出现
   - 在构造器的首行，没有显式的声明“this（形参列表）”或“super（形参列表）”，则默认调用的是父类中空参的 构造器
   - 在类的多个构造器中至少有一个构造器使用了“super（形参列表）”，调用父类中的构造器

#### instanceof关键字使用

1. **a instanceof A​**:判断对象a是否是类A的实例，如果是返回true，如果不是返回false​
2. 使用情景：为了避免在向下转型时出现ClassCastException异常，在向下转型之前，先进行instanceof的判断，返回true则转型，返回false不进行向下转型

#### final关键字

1. final可以用来修饰的结构：**类、方法、变量**
2. final 用来修饰一个类:**此类不能被其他类所继承。**
   - 比如：String类、System类、StringBuffer类
3. final 用来修饰方法：表明此**方法不可以被重写**
   - 比如：Object类中getClass();
4. final 用来修饰变量：此时的"**变量"就称为是一个常量**
   *          final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
   *          final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
5. **static final 用来修饰属性：全局常量**

## java.lang.Object类的使用

1. Object类是所有Java类的**根父类**
2. 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类。
3. Object类中的功能（属性，方法）具有通用性
   - 属性：无
   - 方法：**equals()/toString()**/getClass()反射的时候/hashCode()/clone()/finalize()/wait()/notify()/notifyAll()
4. Object类只声明了一个空参构造器
5. 方法：
   - **==**和**equals**的区别
     1. ==既可以比较基本类型也可以比较引用类型。对于**基本类型**（不一定要类型相同）就是比较**值**,对于**引用类型**就是比较**内存地址**
     2. equals的话,它是属于java.lang.Object类里面的方法,如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的,而且String类在日常开发中用的比较多,久而久之,形成了equals是比较值的错误观点。
     3. 具体要看自定义类里有没有重写object的equals方法来判断。
     4. 通常情况下,重写equals方法,会比较类中的相应属性是否都相等。
   - **“==”运算符**
     1. 可以使用在基本数据类型变量和引用数据类型变量中
     2. 若比较的是基本数据类型变量，比较两个变量存在的值是否相同（比一定要类型相同）
     3. 若比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体
   - **equals（）方法的使用**
     1. 是一个方法，而不是运算符
     2. 只能适用于引用数据类型
     3. Object类中equals（）的作用与“==”相同，比较两个对象的地址值是否相同
     4. 像**String,Date,File,包装类**等都重写了Object类中equals方法，重写后不是比较的引用地址，而是比较两个对象的**“实体内容”**是否相同
     5. 通常情况下，自定义的类如果使用equals（）方法的话，也通常是比较两个对象的实体内容是否相同，那么就需要对Object类中的equals（）方法进行重写。
     6. 重写的原则：比较两个对象的实体内容是否相同
   - **Object类中toString()函数**
     1. 当输出一个对象时，实际上是调用当前对象得toString()方法
     2. String，Date,File 包装类都重写了Object类中得 toString()方法，在调用对象的toString方法时，返回“实体内容”信息
     3. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”
   - 
6. 单元测试
   - 步骤
     1. 选中当前工程——右键选择：bulid path  --  add libraries  -  JUnit4  -  下一步
     2. 创建Java类，进行单元测试。
        - 此时Java类要求，1、**此类时public**，2、此类提供**公共的无参构造器**
     3. 此类中声明单元测试方法。单元测试方法权限是public，没有返回值，没有形参
     4. 此单元测试方法上一行需要声明注解;**@Test**,并在单元测试类中导入：**import org.junit.test**
     5. 声明好单元测试类方法后，就可以在方法体内测试相关代码
     6. 写完代码以后，左键双击单元测试名，右键：run as   -   JUnit  Test
   - 说明
     1. 执行结果没有任何异常，绿条，异常，红条

## 包装类（Wrapper)的使用

1. ,针对**八种基本数据类型定义相应的引用类型-包装类(封装类)**,有了类的特点,就可以调用类中的方法, Java才是真正的面问对象
2. ![image-20210809152309872](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210809152309872.png)
3. 基本数据类型，包装类，String三者之间的相互转换。
   - 基本数据类型——>包装类
     1. 调用包装类的构造器
   - 包装类——>基本数据类型
     1. 调用包装类的xxxValue（）方法
   - 基本数据类型，包装类——>String类型
     1. 调用String重载的valueOf(Xxx   xxx)
     2. 用“+”做连接运算
   - String类型——>基本数据类型，包装类
     1. 调用包装类的parseXxx()
4. JDK5.0新特性：**自动拆箱，自动装箱**
5. Integer内部定义了IntegerCach结构，其中定义了Integer[],保存了-128——127范围内时，可以直接使用数组中的元素，不能再去new了，目的：提高效率

## 抽象类和抽象方法

1. abstract:抽象的
2. abstract可以用来修饰的结构：类、方法
3. abstract修饰类：**抽象类**
   * 		**此类不能实例化**
   * 		**抽象类中一定有构造器，便于子类实例化时调用**（涉及：子类对象实例化的全过程）
   * 		**开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作**
4. abstract修饰方法：**抽象方法**
   * 		抽象方法只有**方法的声明，没有方法体**
   * 		包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。
   * 		若子类重写了父类中的所有的抽象方法后，此子类方可实例化
   * 		若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

5. abstract使用上的注意点：
   - abstract不能用来修饰：属性、构造器等结构
   - abstract不能用来修饰**私有方法、静态方法、final的方法、final的类**
6. 多态的应用，模板方法设计模式
   - **抽象类体现的就是一种模板模式的设计,抽象类作为多个子类的通用模板,子类在抽象类的基础上进行扩展、改造,但子类总体上会保留抽象类的行为方式。**
   - 解决的问题
     - 当功能内部一部分实现是确定的,一部分实现是不确定的。这时可以把不确定的部分暴露出去,让子类去实现。
     - **换句话说,在软件开发中实现一个算法时,整体步骤很固定、通用,这些步骤已经在父类中写好了。但是某些部分易变,易变部分可以抽象出来,供不同子类实现。这就是一种模板模式。**

## 接口（interface)

1. java中，接口和类是并列的两个结构
2. 如何定义接口，定义接口中的成员？
   - **JDK7及以前**：**只能定义全局常量和抽象方法**
     - 全局常量：**public static final，书写时可以省略不写**
     - 抽象方法：**public abstract**
   - **JDK8**：除了定义全局常量和抽象方法，还可以定义**静态方法，默认方法**
     - 接口中定义的静态方法，只能通过**接口调用**
     - 通过实现**类的对象**，可以**调用接口中的默认方法**
     - **如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法**
     - 如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是**父类中的同名同参数的方法**。-->**类优先原则**
     - 如果实现类实现了**多个接口**，而这多个接口中定义了**同名同参数的默认方法**，**那么在实现类没有重写此方法的情况下，报错。-->接口冲突。**——这就需要我们必须在**实现类中重写此方法**
3. **接口中不能定义构造器**，意味着接口不能实例化
4. Java开发中，**接口通过用类去实现（implements)的方式来使用**；如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化；如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
5. **Java类可以实现多个接口 ————>弥补了Java单继承性的局限性**
   - 格式：**class** AA **extends** BB **implements** CC,DD,EE
6. **接口与接口之间**可以继承，而且可以**多继承**
7. 接口的具体使用体现**多态性**
8. 接口，实际上可以看作是一种规范
9. 接口的使用：
   - 接口使用上也满足多态性
   - 接口实际上就是定义了一种规范
   - 开发中体会面向接口编程
   - **代理模式**
     - 安全代理
     - 远程代理
     - 延迟加载
     - **静态代理**
     - **动态代理**

## 代码块（类的内部成员之四）

1. 代码块的作用：用来初始化**类、对象**
2. 代码块如果有修饰的话，只能使用**static.**
3. 分类：**静态代码块** vs 非静态代码块
4. **静态代码块**
   - 内部可以有输出语句
   - 随着类的加载而执行,而且只执行一次
   - 作用：**初始化类的信息**
   - **如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行**
   - **静态代码块的执行要优先于非静态代码块的执行**
   - 静态代码块内只能调用**静态的属性、静态的方法**，不能调用非静态的结构
5. **非静态代码块**
   - 内部可以有输出语句
   - 随着对象的创建而执行
   - 每创建一个对象，就执行一次非静态代码块
   - 作用**：可以在创建对象时，对对象的属性等进行初始化**
   - 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
   - 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法

## 内部类（类的内部成员之五）

1. Java中允许将一个类A声明在另一个类B中，则**类A就是内部类，类B称为外部类**
2. 内部类的分类：**成员内部类**（静态、非静态）  vs **局部内部类**(方法内、代码块内、构造器内)
3. 成员内部类
   - 一方面，作为外部类的成员：
     - 调用外部类的结构
     - 可以被static修饰
     - 可以被4种不同的权限修饰
   - 另一方面，作为一个类：
     - 类内可以定义属性、方法、构造器等
     - 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
     - 可以被abstract修饰
4. 关注如下的3个问题
   - 如何实例化成员内部类的对象
   - 如何在成员内部类中区分调用外部类的结构
   - 开发中局部内部类的使用  见《InnerClassTest1.java》

## 异常

1.  Error:Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。
2.  ![image-20210816133412418](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210816133412418.png)
3.  ![image-20210910142835765](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210910142835765.png)
4.  ![image-20210910142946851](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210910142946851.png)
5.  绿色为编译时异常（受检异常），红色为运行时异常（非受检异常）
6.  **异常体系结构**
    - **java.lang.Throwable**
      1. java.lang.**Error**:一般不编写针对性的代码进行处理。
      2. java.lang.**Exception**:可以进行异常的处理
         - **编译时异常(checked)**
           1. IOException
              - FileNotFoundException
           2. ClassNotFoundException
         - **运行时异常(unchecked,RuntimeException)**
           1. NullPointerException**空指针异常**
           2. ArrayIndexOutOfBoundsException**数组越界**
           3. ClassCastException**类型转换**
           4. NumberFormatException**字符转数字**
           5. InputMismatchException
           6. ArithmeticException**算术错误**
7.  **异常处理机制**
    - 异常的处理**抓抛模型**
      - 过程一：”抛“：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。 并将此对象抛出，一旦抛出对象以后，其后的代码就不再执行。
        - 异常对象的产生：①	系统自动生成的异常对象，②手动的生成一个异常对象，并抛出（throw)
      - 过程二：“抓”：可以理解为异常的处理方式：①try-catch -finally;②throws
    - **try -catch-finally的使用**
      - finally是可选的
      - 使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象类型，去catch中进行匹配
      - 一旦try中的异常对象匹配到一个catch时，就进入catch中进行异常处理，一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况下）继续执行其后的代码
      - catch中的异常类型如**果没有子父类关系**，则谁声明在上，谁声明在下无所谓
      - catch中的异常类型如果**满足子父类关系**，则要求子类一定要声明在父类的上面，否则报错
      - 常用异常对象处理的方式：
        - **String  getMessage()**返回异常发生时的简要描述
        - **printStackTrace（）**在控制台上打印 `Throwable` 对象封装的异常信息
        - **public String toString()**:返回异常发生时的详细信息
      - 在try结构中声明的变量，出了try结构以后，就不能被调用
      - **使用try-catch -finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍有可能报错，相当于将编译时可能出现的异常，延迟到运行时出现。**
      - 开发中，由于运行时异常比较常见，所以通常不针对运行时异常编写try-catch-finally了，针对编译时异常，一定要考虑异常的处理
    - try -catch-finally中finally的使用
      - finally是可以选择的
      - finally中声明的是一定会被执行的代码。即catch中又出现了异常，try中有return语句，catch中有return语句等情况
      - 像**数据库连接、输入输出流、网络编程Socket等资源**，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。
    - **异常处理二：throws+异常类型**
      - 写在方法的声明处，指明方法执行时，可能会抛出的异常类型，一旦当方法执行时出现异常， 仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。**异常代码的后续代码就不会再被执行**
    - **try -catch-finally的使用**真正的将异常给处理掉了，throws的方式只是将异常抛给了方法的调用者，并没有将异常处理掉。
8.  **重写方法异常抛出的规则：**
    - 子类重写的方法抛出的异常类型**不大于父类**被重写方法抛出的异常类型，
9.  **开发中如何选择try-catch-finally还是throws？**
    - 如果父类中被重写的方法没有throws方法处理异常，子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用**try-catch-finally**方式处理
    - 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议**这几个方法使用throws的方式**进行处理。而执行的**方法a可以考虑使用try-catch-finally方式进行处理。**
10.  **手动抛出异常**
11.  **自定义异常类**
     - 如何自定义异常类？
       - 继承于现有的异常结构：RuntimeException,Exception
       - 提供全局常量：serialVersionUID
       - 提供重载构造器

# Java高级

## 锁https://mp.weixin.qq.com/s/GU42BjM5jY2CEMVD_PAZBQ

![image-20211014213130126](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20211014213130126.png)

#### 从线程是否需要对资源加锁可以分为 `悲观锁` 和 `乐观锁`

**悲观锁：**在持有数据的时候总会把`资源` 或者 `数据` 锁住：传统的关系型数据库里边就用到了很多这种锁机制，**比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。**悲观锁的实现往往依靠数据库本身的锁功能实现。Java 中的 **Synchronized和 ReentrantLock** 等独占锁(排他锁)也是一种悲观锁思想的实现

**乐观锁**总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁的实现方案一般来说有两种：**版本号机制和 CAS实现** 。乐观锁多适用于多读的应用类型，这样可以提高吞吐量。

在Java中**java.util.concurrent.atomic**包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的

**版本号机制**：是在数据表中加上一个 `version` 字段来实现的，表示数据被修改的次数。**当执行写操作并且写入成功后，version = version + 1，**当线程A要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

**CAS算法：**CAS 即 `compare and swap（比较与交换）`，是一种**有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步**，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫**非阻塞同步（Non-blocking Synchronization）**

Java 从 JDK1.5 开始支持，**java.util.concurrent** 包里提供了很多面向并发编程的类，也提供了 CAS 算法的支持，**一些以 `Atomic` 为开头的一些原子类都使用 CAS 作为其实现方式**。使用这些类在多核 CPU 的机器上会有比较好的性能。

如果要保证它们的原子性，必须进行加锁，使用 `Synchronzied` 或者 `ReentrantLock`，我们前面介绍它们是悲观锁的实现，我们现在讨论的是乐观锁，那么用哪种方式保证它们的原子性呢？请继续往下看

**CAS 中涉及三个要素：**

- **需要读写的内存值 V**
- **进行比较的值 A**
- **拟写入的新值 B**

当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

**乐观锁的缺点：**

1. ABA问题；
2. **循环开销大**：乐观锁在进行写操作的时候会判断是否能够写入成功，如果**写入不成功将触发等待 -> 重试**机制，这种情况是一个自旋锁，简单来说就是**适用于短期内获取不到，进行等待重试的锁**，它不适用于长期获取不到锁的情况，另外，**自旋循环对于性能开销比较大**

**CAS与synchronized的使用情景**

1.  **CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）**
2. 对于资源竞争较少（线程冲突较轻）的情况，使用 Synchronized 同步锁进行**线程阻塞和唤醒切换**以及**用户态内核态**间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
3. 对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。

#### 从资源已被锁定，线程是否阻塞可以分为 `自旋锁`

1. **提出背景**

   由于在多处理器环境中某些资源的有限性，有时需要**互斥访问(mutual exclusion)**，这时候就需要引入锁的概念，**只有获取了锁的线程才能够对资源进行访问**，由于**多线程的核心是CPU的时间分片**，所以**同一时刻只能有一个线程获取到锁**。

   那么就面临一个问题，**那么没有获取到锁的线程应该怎么办**？

   通常有两种处理方式：一**种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁**，这种锁叫做**自旋锁**，它不用将线程`阻塞起来(NON-BLOCKING)`；还有一种处理方式就是**把自己阻塞起来，等待重新调度请求**，这种叫做**互斥锁**。

2. **自旋锁**

   当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用**循环加锁 -> 等待**的机制被称为**自旋锁(spinlock)**

3. **原理**

   如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做**内核态和用户态**之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用**户进程和内核切换的消耗**

   > **内核**从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。
   >
   > **用户态**即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括 CPU 资源、存储资源、I/O 资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即**系统调用**
   >
   > **系统调用是操作系统的最小功能单位**
   >
   > 用户态的应用程序可以通过三种方式来访问内核态
   >
   > 1. 系统调用
   > 2. 库函数
   > 3. Shell 脚本

   **自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。**

   但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此**自旋的周期选的额外**重要！

   JDK在1.6 引入了适应性自旋锁，**适应性自旋锁意味着自旋时间不是固定的了**，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。

4. **优缺点**

   **自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈**，**且占用锁时间非常短的代码块来说性能能大幅度的提升**，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

   但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。

5. **自旋锁实现：**

   - 简单自旋锁**无法保证多线程竞争的公平性**。可能会造成某些线程**一直都未获取到锁**造成**线程饥饿**。

   - **排队自旋锁**，如**TicketLock，MCSLock，CLHLock**。

     - **TicketLock** 是基于**先进先出(FIFO) 队列**的机制。有两个 int 类型的数值，开始都是0，**第一个值是队列ticket(队列票据)， 第二个值是 出队(票据)**。队列票据是线程在队列中的位置，而出队票据是现在持有锁的票证的队列位置。

     - #### CLHLock 就是基于链表设计的。是一种基于链表的可扩展，高性能，公平的自旋锁，申请线程只能在本地变量上自旋，它会不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。

     - **MCS Spinlock** 是一种基于**链表**的**可扩展、高性能、公平**的自旋锁，申请线程只在本地变量上自旋，**直接前驱负责通知其结束自旋**，从而极大地**减少了不必要的处理器缓存同步的次数**，降低了总线和内存的开销。

#### 从多个线程并发访问资源，也就是 Synchronized 可以分为 `无锁`、`偏向锁`、 `轻量级锁`和 `重量级锁`

Hopspot 对象头主要包括两部分数据**Mark Word（标记字段）**和 **class Pointer（类型指针）**。 **synchronized 是悲观锁，在操作同步之前需要给资源加锁，这把锁就是对象头里面**

1. **Mark Word（标记字段）**默认存储**对象的HashCode**，**分代年龄**和**锁标志位信息**。
2. **class Point**：**对象指向它的类元数据的指针**，虚拟机通过这个指针来确定这个对象是哪个类的实例

![image-20211014230617847](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20211014230617847.png)

- 无状态也就是**无锁**的时候，对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01

  

- **偏向锁** 中划分更细，还是开辟25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放 epoch，4bit 存放分代年龄，**1bit 存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01**

  

- **轻量级锁**中直接开辟 **30bit** 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为00

  

- **重量级锁**中和轻量级锁一样，30bit 的空间用来存放指向重量级锁的指针，2bit 存放锁的标识位，为11

  

- GC标记开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。

##### Synchronized锁

**synchronized**用的锁是存在Java对象头里的。

**JVM基于进入和退出 Monitor 对象来实现方法同步和代码块同步**。代码块同步是使用 monitorenter 和 monitorexit 指令实现的，monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。

根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行 monitorexit 指令时会将锁计数器减1，当计数器被减到0时，锁就释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。

##### Monitor

**Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。**

而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为`重量级锁`。

Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了`偏向锁`和`轻量级锁`：锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级**。

所以锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。

随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。

JDK 1.6中默认是开启偏向锁和轻量级锁的，我们也可以通过-XX:-UseBiasedLocking=false来禁用偏向锁。

#### 从锁的公平性进行区分，可以分为`公平锁` 和 `非公平锁`

- **公平锁**表示线程获取锁的顺序是**按照线程加锁的顺序来**分配的，即**先来先得的FIFO先进先出顺序**。

  - **ReetrantLock实现公平锁**
  - **FairSync** 其实是一个 **Sync**的内部类，它的主要作用是同步对象以获取公平锁。而**Sync 是 ReentrantLock 中的内部类**，**Sync 继承 `AbstractQueuedSynchronizer` 类**，**AbstractQueuedSynchronizer 就是我们常说的 AQS** ，它是 JUC（java.util.concurrent） 中最重要的一个类，通过它来实现**独占锁和共享锁。**

- 而**非公平锁**就是一种**获取锁的抢占机制**，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果也就是不公平的了。

- ### ReentrantLock 基本概述

  **ReentrantLock** 是一把**可重入锁**，也是一把**互斥锁**，它具有与 `synchronized` 相同的方法和监视器锁的语义，但是它比 synchronized 有更多可扩展的功能。

  **ReentrantLock 的可重入性是指它可以由上次成功锁定但还未解锁的线程拥有**。当只有一个线程尝试加锁时，该线程调用 `lock()` 方法会立刻返回成功并直接获取锁。如果当前线程已经拥有这把锁，这个方法会立刻返回。可以使用 `isHeldByCurrentThread` 和 `getHoldCount` 进行检查。

  这个类的构造函数接受可选择的 fairness 参数，当 fairness 设置为 true 时，在多线程争夺尝试加锁时，锁倾向于对等待时间最长的线程访问，这也是公平性的一种体现。

  否则，锁不能保证每个线程的访问顺序，也就是非公平锁。与使用默认设置的程序相比，使用许多线程访问的公平锁的程序可能会显示`较低`的总体吞吐量（即较慢；通常要慢得多）。但是获取锁并保证线程不会饥饿的次数比较小。

  无论如何请注意：**锁的公平性不能保证线程调度的公平性**。因此，使用公平锁的多线程之一可能会连续多次获得它，而其他活动线程没有进行且当前未持有该锁。这也是`互斥性` 的一种体现。

  也要注意的 `tryLock()` 方法不支持公平性。如果锁是可以获取的，那么即使其他线程等待，它仍然能够返回成功。

- ### ReentrantLock 如何实现锁公平性

  调用 `Lock.lock()` 方法其实是调用了 `sync` 的内部的方法，而 sync 是最基础的同步控制 Lock 的类，它有公平锁和非公平锁的实现。它继承 `AbstractQueuedSynchronizer` 即 使用 AQS 状态代表锁持有的数量。

#### 从根据锁是否重复获取可以分为 `可重入锁` 和 `不可重入锁`

**可重入锁又称为递归锁**，是指在**同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class）**，不会因为之前已经获取过还没释放而阻塞。

Java 中 **ReentrantLock**和**synchronized**都是可重入锁，可重入锁的一个优点是在一定程度上可以避免死锁。

```java
private synchronized void doSomething(){
  System.out.println("doSomething...");
  doSomethingElse();
}

private synchronized void doSomethingElse(){
  System.out.println("doSomethingElse...");
}
```

如果 synchronized 是不可重入锁的话，那么在调用 doSomethingElse() 方法的时候，必须把 doSomething() 的锁丢掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。

也就是说，**不可重入锁会造成死锁**

#### 从那个多个线程能否获取同一把锁分为 `共享锁` 和 `排他锁`

独占多和共享锁一般对应 JDK 源码的 ReentrantLock 和 ReentrantReadWriteLock 源码来介绍独占锁和共享锁。

**独占锁又叫做排他锁，是指锁在同一时刻只能被一个线程拥有，其他线程想要访问资源，就会被阻塞**。JDK 中 synchronized和 JUC 中 Lock 的实现类就是互斥锁。

**共享锁指的是锁能够被多个线程所拥有，如果某个线程对资源加上共享锁后，则其他线程只能对资源再加共享锁**，不能加排它锁。**获得共享锁的线程只能读数据，不能修改数据**。

## 常用类

### 字符串相关的类

1. String：字符串	使用一对“”引起来表示

   - string声明为final，不可被继承
   - string实现了Serializable接口：表示字符串是支持序列化的
   - 实现类Comparable接口：表示String可以比较大小
   - String内部定义了final  char[]   value用于存储字符串数据
   - String：代表不可变的字符序列。简称：**不可变性**
     - **当对字符串重新赋值时**，需要**重写指定内存区域**赋值，不能使用原有value赋值
     - **当对现有的字符串进行连接操作时**，需要重写指定内存区域赋值，不能使用原有value修改
     - 当调用string的replace方法修改指定字符或字符串时，需要重写指定内存区域赋值，不能使用原有value修改
   - 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在**字符串常量池**中
   - 字符串常量池中不会存储相同内容的字符串的。

2. String：实例化方式

   - 方式一：通过字面量定义的方式：**方法区的字符串常量池中**
   - 方式二;通过new + 构造器的方式：数据在**堆空间**中
   - 面试题：String s = new String("abc");方式创建对象，在内存中创建了几个对象？
         两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据："abc"
   - 结论：
     - 常量与常量的拼接结果在常量池中，且常量池中不会存在相同内容的常量
     - 只要其中有一个是变量，结果就在堆中。
     - 如果拼接的结果调用intern()方法，返回值就在常量池中

3. **String与基本数据类型和包装类**之间的转换

   - String——>基本数据类型，包装类，调用包装类的静态方法：parseXxx(str)

   - 基本数据类型，包装类——>String,调用String重载的valueOf(xxx)

   - ```java
         public void test1(){
             String str1 = "123";
     //        int num = (int)str1;//错误的
             int num = Integer.parseInt(str1);
     
             String str2 = String.valueOf(num);//"123"
             String str3 = num + "";
     
             System.out.println(str1 == str3);
         }
     ```

     

4. **String与char[]数组之间的转换**

   - String——>char[],调用String类的toCharArray()
   - char[]——>String，调用String的构造器

5. **string常用函数**

   ```java
   StringBuffer的常用方法：
   StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接
   StringBuffer delete(int start,int end)：删除指定位置的内容
   StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str
   StringBuffer insert(int offset, xxx)：在指定位置插入xxx
   StringBuffer reverse() ：把当前字符序列逆转
   public int indexOf(String str)
   public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串
   public int length()
   public char charAt(int n )
   public void setCharAt(int n ,char ch)
   ```

   

6. **String与byte[]数组之间的转换**

   - 编码String——>byte[],调用String类的getBytes()
   - 解码：byte[]——>String，调用String类的构造器
     - **编码**：字符串——>字节（看的懂——>看不懂二进制数据）
     - **解码：编码的逆过程**，字节——>字符串（看不懂二进制数据——>看的懂）
     - 解码时要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码

7. **StringBuffer和StringBuilder使用**

   - **String与StringBuffer和StringBuilder异同**
     1. String：不可变字符序列，底层使用char[]存储
     2. StringBuffer:可变的字符序列，**线程安全的，效率低**；底层使用char[]存储
     3. StringBuilder：可变的字符序列，**线程不安全，效率高  jdk5.0新增**；底层使用char[]存储
     4. 三者的效率：StringBuilder  >  StringBuffer   >   String

### 日期和时间API

1. JDK8.0之前的日期和时间API

   - System类中的currentTimeMillis()  称为**时间戳**

2. java.util.Date类

   - java.sql.Date类

3. 两个构造器的使用

   - 构造器一：Date()：创建一个对应当前时间的Date对象
   - 构造器二：创建指定毫秒数的Date对象

4. 两个方法的使用

   - toString():显示当前的年、月、日、时、分、秒
   - getTime():获取当前Date对象对应的毫秒数。（时间戳）

5. java.sql.Date对应着数据库中的日期类型的变量

   如何实例化

   如何将java.util.Date对象转换为java.sql.Date对象

6. jdk 8之前的日期时间的API测试

   - System类中currentTimeMillis();

   - java.util.Date和子类java.sql.Date

   - SimpleDateFormat

     1. 格式化：日期 --->字符串
     2. 解析：格式化的逆过程，字符串 ---> 日期

   - Calendar日历类（抽象类）的使用

     1. 实例化

        方式一：创建其子类（GregorianCalendar）的对象

        方式二：调用其静态方法getInstance()

     2. 常用方法：

        get()

        set()——calendar可变性

        add()

        getTime:日历类——>Date

        setTime:Date —— >日历类

7. jdk 8中日期时间API的测试

   - LocalDate、LocalTime、LocalDateTime 的使用
   - LocalDateTime相较于LocalDate、LocalTime，使用频率要高
   - 类似于Calendar
   - Instant的使用
   - DateTimeFormatter:格式化或解析日期、时间类，似于SimpleDateFormat

### Java比较器

1. Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 > 或 < 的，但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小，如何实现？使用两个接口中的任何一个：Comparable 或 Comparator

2. **Comparable接口与Comparator**的使用的对比：

   Comparable接口的方式一旦一定，**保证Comparable接口实现类的对象在任何位置都可以比较大小**。

   **Comparator接口属于临时性的比较**。

3. **Comparable接口**的使用举例：  **自然排序**

   - 像String、包装类等实现了Comparable接口，重写了**compareTo(obj)**方法，给出了比较两个对象大小的方式。
   - 像String、包装类重写compareTo()方法以后，进行了从小到大的排列
   - 重写**compareTo(obj)的规则**：
     - 如果当前对象this**大于**形参对象obj，则返回**正整数，**
     - 如果当前对象this**小于**形参对象obj，则返回**负整数**，
     - 如果当前对象this**等于**形参对象obj，则返回**零**
   - 对于自定义类来说，如果需要排序，我们可以让**自定义类实现Comparable接口，重写compareTo(obj)方法**。
     - 在compareTo(obj)方法中指明如何排序

4. **Comparator**接口的使用：**定制排序**

   1. 背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 **Comparator 的对象来排序**
   2. 重写**compare(Object o1,Object o2)方法，比较o1和o2的大小**：
      - 如果方法返回正整数，则表示o1大于o2；
      - 如果返回0，表示相等；
      - 返回负整数，表示o1小于o2。

### 枚举类

1. 枚举类的使用

   - 类的对象只有有限个，确定的。此类为枚举类
   - 当需要定义一组常量时，强烈建议使用枚举类。
   - 如果枚举类中只有一个对象，则可以作为单例模式的实现方式
2. 如何定义枚举类

   - 方式一：JDK5.0之前，自定义枚举类
   - 方式二：jdk5.0,可以使用enum关键字定义枚举类
3. enum常用方法

   - values（）返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。
   - valueOf(String str)可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
   - toString()返回当前枚举类对象常量的名称
4. **使用enum关键字定义的枚举类实现接口的情况**

   - 情况一：实现接口，在enum类中实现抽象方法
   - 情况二：让枚举类的对象分别实现接口中的抽象方法

### Object类

- Object 类是一个特殊的类，是所有类的父类

- ```
  public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。
  
  public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
  public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。
  
  protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。
  
  public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。
  
  public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
  
  public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
  
  public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。
  
  public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
  
  public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
  
  protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作
  ```



## 注解

1. **框架 = 注解 + 反射 + 设计模式**

2. 理解Annotation

   - **jdk 5.0 新增的功能**
   - Annotation 其实就是代码里的特殊标记, 这些标记可以在**编译, 类加载, 运行时被读取**, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。
   - 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android，中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗，代码和XML配置等。

3. Annocation的使用示例

   - 示例一：生成文档相关的注解

   - 示例二：在编译时进行格式检查(JDK内置的三个基本注解)

     @Override: 限定重写父类方法, 该注解只能用于方法

     @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择

     @SuppressWarnings: 抑制编译器警告

   - 示例三：跟踪代码依赖性，实现替代配置文件功能

4. 如何自定义注解，参照@SuppressWarnings定义

   - 注解声明为@interface
   - 内部定义成员，通常使用value，
   - 可以指定成员的默认值，使用default定义
   - 如果自定义注解没有成员，表明是一个标识作用
   - 如果注解有成员，在使用注解时，需要指明成员的值
   - 自定义注解必须配上注解的信息处理流程（使用反射）才有意义

5. jdk提供的**元注解**——修饰其它注解的注解

   - **Retention**：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME只有声明为RUNTIME生命周期的注解，才能通过反射获取
   - **Target**:用于指定被修饰的 Annotation 能用于修饰哪些程序元素
   - **Documented**:表示所修饰的注解在被javadoc解析时，保留下来。
   - **Inherited**:被它修饰的 Annotation 将具有继承性。

6. 通过反射获取注解信息 ---到反射内容时系统讲解

7. jdk 8 中注解的新特性：可重复注解、类型注解

   - 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class

     ​						② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。

   - 类型注解：

     - ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。
     - ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。


## Java集合

1. 概述：

   - **集合、数组**都是对多个数据进行存储操作的结构，简称**Java容器**。

     说明：此时的存储，主要指的是**内存层面的存储**，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）

   - **数组**在存储多个数据方面的特点：

     - **一旦初始化以后，其长度就确定了**

     - 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。

       比如：String[] arr;int[] arr1;Object[] arr2;

   - 数组在存储多个数据方面的缺点：

     - 一旦初始化以后，**其长度就不可修改**。
     - 数组中提供的方法非常有限，对于**添加、删除、插入数据**等操作，非常不便，同时效率不高。
     - 获取**数组中实际元素的个数的需求**，数组没有现成的属性或方法可用
     - 数组存储数据的特点：**有序、可重复**。对于无序、不可重复的需求，不能满足。

2. 集合框架：

   ![image-20210925084637034](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210925084637034.png)

   1. |----Collection接口：单列集合，用来存储一个一个的对象

      - |----**List接口**：存储有序的、可重复的数据。  -->“动态”数组

        - |----**ArrayList**、**LinkedList**、**Vector**

      - |----**Set接口**：存储无序的、不可重复的数据   -->高中讲的“集合”

        -  |----**HashSet、LinkedHashSet、TreeSet**

      - #### Queue

        -  **PriorityQueue**: Object[]  数组来实现**二叉堆**
        -  **ArrayQueue**: Object[]**数组 + 双指针**

   2. |----Map接口：双列集合，用来存储**一对(key - value)一对的数据**   -->高中函数：y = f(x)

      - |----**HashMap、LinkedHashMap、TreeMap**、Hashtable、Properties

3. 集合元素的遍历使用迭代器Iterator接口

   - 1.内部的方法：**hasNext() 和  next()**

   - 2.集合对象每次调用**iterator()方法都得到一个全新的迭代器对象**，

     默认游标都在集合的第一个元素之前。

   - 内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()

4. jdk 5.0 新增了foreach循环，用于遍历集合、数组

### Collection 子接口之List接口

- 存储有序的可重复的数据——>动态数组，替换原有的数组

- 面试题：

  **ArrayList,LinkedList,Vector三者的异同？**

  相同点：三者都是实现List接口，存储数据的特点相同；存储有序的可重复的数据

  不同点：

  - ArrayList：作为List接口的主要实现类；**线程不安全的，效率高**；底层使用Object[] elementData存储
  - LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用**双向链表存储**(**JDK1.6 之前为循环链表**，**JDK1.7 取消了循环**)
  - Vector：作为List接口的古老实现类；**线程安全的，效率低**；底层使用Object[] elementData存储

- **ArrayList的源码分析：**

  1. **jdk 7情况下**

     - **ArrayList list = new ArrayList()**;//底层创建了**长度是10**的Object[]数组elementData

     - **list.add(123)**;//elementData[0] = new Integer(123);

       。。。。

       list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。

       默认情况下，**扩容为原来的容量的1.5倍**，同时需要将原有数组中的数据复制到新的数组中。

     - 结论：**建议开发中使用带参的构造器**：ArrayList list = new ArrayList(int capacity)

  2. **jdk 8中ArrayList的变化：**

     - ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.**并没有创建**长度为10的数组

     - list.add(123);//**第一次调用add()时**，**底层才创建了长度10的数组**，并将数据123添加到elementData[0]

       。。。。。

       后续的添加和扩容操作与jdk 7 无异。

  3. 小结：

     - **jdk7**中的ArrayList的对象的创建类似于**单例的饿汉式**，而**jdk8**中的ArrayList的对象的创建类似于**单例的懒汉式**，**延迟了数组的创建，节省内存**

  4. **LinkedList的源码分析：**

     - LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null

     - list.add(123);//将123封装到Node中，创建了Node对象。

     - 其中，Node定义为：体现了LinkedList的双向链表的说法

       private static class Node<E> {

       ​		E item;

       ​		Node<E> next;

       ​		Node<E> prev;

       ​		Node(Node<E> prev, E element, Node<E> next) {

       ​				this.item = element;

       ​				this.next = next;

       ​				this.prev = prev;

       ​		}

       }

  5. **Vector的源码分析**：jdk7和jdk8中通过Vector()构造器创建对象时，**底层都创建了长度为10的数组**。在扩容方面，默认扩容为原来的**数组长度的2倍。**

- **List接口中的常用方法：**

  - void **add**(int index, Object ele):在index位置插入ele元素
  - boolean **addAll**(int index, Collection eles):从index位置开始将eles中的所有元素添加进来
  - Object **get**(int index):获取指定index位置的元素
  - int **indexOf**(Object obj):返回obj在集合中首次出现的位置
  - int **lastIndexOf**(Object obj):返回obj在当前集合中末次出现的位置
  - Object **remove**(int index):移除指定index位置的元素，并返回此元素
  - Object **set**(int index, Object ele):设置指定index位置的元素为ele
  - List **subList**(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合
  - **常用方法：**
    1. 增：add(Object obj)
    2. 删：remove(int index) / remove(Object obj)
    3. 改：set(int index, Object ele)
    4. 查：get(int index)
    5. 插：add(int index, Object ele)
    6. 长度：size()
    7. 遍历：**① Iterator迭代器方式；② 增强for循环；③ 普通的循环；**

### Collection 子接口之set接口

- set接口的框架

  - |----Collection接口：单列集合，用来存储一个一个的对象

    ​		|----Set接口：**存储无序的、不可重复的数据**   -->高中讲的“集合”

    ​				|----**HashSet**：作为Set接口的主要实现类；**线程不安全**的；可以存储null值

    ​						|----**LinkedHashSet**：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历																操作，LinkedHashSet效率高于HashSet.

    ​				|----**TreeSet**：**可以按照添加对象的指定属性，进行排序**。

- Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。

- 要求：

  1. 向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()
  2. 重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码；
  3. 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。

- **Set：存储无序的、不可重复的数据**

  1. 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
  2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。

- **添加元素的过程：以HashSet为例：**

  我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：

  ​		如果此位置上没有其他元素，则元素a添加成功。 --->情况1

  ​		如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：

  ​				如果hash值不相同，则元素a添加成功。--->情况2

  ​				如果hash值相同，进而需要调用元素a所在类的equals()方法：

  ​						equals()返回true,元素a添加失败

  ​						equals()返回false,则元素a添加成功。--->情况3

  对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。

  jdk 7 :元素a放到数组中，指向原来的元素。

  jdk 8 :原来的元素在数组中，指向元素a

  **总结：七上八下**

​		**HashSet底层：数组+链表的结构。**

- **LinkedHashSet的使用**

  LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。

  优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet

- **TreeSet**

  1. 向TreeSet中添加的数据，**要求是相同类的对象。**
  2. 两种排序方式：**自然排序（实现Comparable接口） 和 定制排序（Comparator）**
  3. 自然排序中，比较两个对象是否相同的标准为：**compareTo()返回0**.不再是equals().
  4. 定制排序中，比较两个对象是否相同的标准为：**compare()返回0**.不再是equals().

- ### **比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同**

  1. `HashSet` 是 `Set` 接口的主要实现类 ，`HashSet` 的底层是 `HashMap`，**线程不安全的**，可以存储 null 值
  2. `LinkedHashSet` 是 `HashSet` 的子类，能够**按照添加的顺序**遍历；
  3. `TreeSet` 底层使用**红黑树**，元素是**有序**的，排序的方式有**自然排序和定制排序**。

### Collection 子接口之 Queue

1. **Queue** 

   - **是单端队列**，只能从一端插入元素，另一端删除元素，实现上一般遵循 **先进先出（FIFO）** 规则。
   - `Queue` 扩展了 `Collection` 的接口，根据 **因为容量问题而导致操作失败后处理方式的不同** 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。
   - ![image-20210925213935983](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210925213935983.png)

2. **Deque**

   - 是**双端队列**，在队列的两端均可以插入或删除元素。
   - Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：
   - ![image-20210925214118270](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210925214118270.png)
   - Deque 还提供有 **push() 和 pop()** 等其他方法，可用于模拟栈。

3. ### [ArrayDeque 与 LinkedList 的区别]

   - `ArrayDeque` 和 `LinkedList` 都实现了 **Deque**接口，两者都具有队列的功能，但两者有什么区别呢？
     - `ArrayDeque` 是基于**可变长的数组和双指针**来实现，而 `LinkedList` 则通过**链表**来实现。
     - `ArrayDeque` **不**支持存储 `NULL` 数据，但 `LinkedList` 支持。
     - `ArrayDeque` 是在 JDK1.6 才被引入的，而`LinkedList` 早在 JDK1.2 时就已经存在。
     - `ArrayDeque` 插入时**可能存在扩容过程**, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` **不需要扩容，但是每次插入数据时均需要申请新的堆空间**，均摊性能相比更慢。
   - 从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。

4. ### [PriorityQueue]

   - `PriorityQueue` 是在 JDK1.5 中被引入的, 其与 `Queue` 的区别在于元素**出队顺序是与优先级相关的**，即总是优先级最高的元素先出队。
     - `PriorityQueue` 利用了**二叉堆**的数据结构来实现的，**底层使用可变长的数组**来存储数据
     - `PriorityQueue` 通过**堆元素的上浮和下沉**，实现了在 **O(logn) 的时间复杂度**内插入元素和删除堆顶元素。
     - `PriorityQueue` 是**非线程安全**的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
     - `PriorityQueue` 默认是**小顶堆**，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。
   - `PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。

### **Map接口**

- **map实现类的结构**

  |----Map:双列数据，**存储key-value对的数据**   ---类似于高中的函数：y = f(x)

  ​		|----**HashMap**:作为Map的主要实现类；**线程不安全的，效率高**；**存储null的key和value**

  ​				|----**LinkedHashMap**:保证在遍历map元素时，可以按照添加的**顺序实现遍历**。

  ​						原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。

  ​						对于频繁的遍历操作，此类执行效率高于HashMap。

  ​		|----**TreeMap**:保证**按照添加的key-value对进行排序**，实现排序遍历。此时考虑key的**自然排序或定制排序**；底层使用**红黑树**

  ​		|----**Hashtable**:作为古老的实现类；线程安全的，效率低；**不能**存储null的key和value

  ​				|----Properties:常用来处理配置文件。key和value都是String类型

  HashMap的底层：**数组+链表**  （jdk7及之前）**数组+链表+红黑树 （jdk 8）**

- **面试题：**

  1. HashMap的底层实现原理？
  2. HashMap 和 Hashtable的异同？
  3. CurrentHashMap 与 Hashtable的异同？（暂时不讲）

- **map结构的理解**

  1. Map中的**key:无序的、不可重复的**，使用**Set存储所有的key**  ---> **key所在的类要重写equals()和hashCode()** （以HashMap为例）
  2. Map中的**value:无序的、可重复的，使用Collection存储所有的value** --->value所在的类要重写equals()
  3. 一个键值对：key-value构成了一个Entry对象。
  4. Map中的**entry:无序的、不可重复的**，使用**Set存储所有的entry**


#### **HashMap的底层实现原理？以jdk7为例说明：**

​		HashMap map = new HashMap():在实例化以后，底层创建了长度是**16**的一维数组Entry[] table。

​		...可能已经执行过多次put...

​		**map.put(key1,value1):**

1. 首先，**调用key1所在类的hashCode()**计算key1哈希值，**此哈希值经过某种算法计算以后**，得到在Entry数组中的存放位置。

​		如果此位置上的数据为空，此时的key1-value1添加成功。 ---**-情况1**

​		如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(**以链表形式存在**)),比较key1和已经存在的一个或多个数据的**哈希值**：

​				如果key1的哈希值与已经存在的数据的**哈希值都不相同**，此时key1-value1添加成功。----**情况2**

​				如果key1的哈希值和已经存在的某一个数据(key2-value2)的**哈希值相同，继续比较**：调用key1所在类的**equals(key2)**方法，比较：

​						如果equals()返回false:此时key1-value1添加成功。----**情况3**

​						如果equals()返回true:**使用value1替换value2**。

​		补充：关于情况2和情况3：此时key1-value1和原来的数据以**链表**的方式存储。

​		在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：**扩容为原来容量的2倍**，**并将原有的数据复制过来**。

- **jdk8 相较于jdk7在底层实现方面的不同：**

  - **new HashMap()**:底层没有创建一个长度为16的数组
  - jdk 8底层的数组是：**Node[],而非Entry[]**
  - **首次调用put()方法时，底层创建长度为16的数组**
  - jdk7底层结构只有：**数组+链表**。jdk8中底层结构：**数组+链表+红黑树**。
    1. 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
    2. 当数组的某一个索引位置上的元素以**链表形式存在的数据个数 > 8 且当前数组的长度 > 64时**，此时此索引位置上的所数据改为使用红黑树存储。
  - **DEFAULT_INITIAL_CAPACITY** : HashMap的**默认容量，16**
  - **DEFAULT_LOAD_FACTOR**：HashMap的默认**加载因子：0.75**
  - threshold：**扩容的临界值，=容量*填充因子**：16 * 0.75 => 12
  - **TREEIFY_THRESHOLD**：**Bucket中**链表长度大于该默认值，转化为红黑树:8
  - **MIN_TREEIFY_CAPACITY**：桶中的Node**被树化时最小的hash表容量:64**

- **LinkedHashMap的底层实现原理（了解）**

  源码中：

   static class Entry<K,V> extends HashMap.Node<K,V> {

  ​		Entry<K,V> before, after;//能够记录添加的元素的先后顺序

  ​		Entry(int hash, K key, V value, Node<K,V> next) {

  ​				super(hash, key, value, next);

  ​		}

  }


#### [HashMap 和 Hashtable 的区别]

- **线程是否安全：** `HashMap` 是非线程安全的，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；
- **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；
- **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；**Hashtable 不允许有 null 键和 null 值**，否则会抛出 `NullPointerException`。
- **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的**初始大小为 11**，之后每次扩充，**容量变为原来的 2n+1**。`HashMap` 默认的**初始化大小为 16**。之后每次扩充，容量变**为原来的 2 倍**。② 创建时如果给定了容量初始值，那么 **Hashtable 会直接使用你给定的大小**，而 `HashMap` 会将其**扩充为 2 的幂次方大小**（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 **2 的幂**作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。
- **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当**链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）**时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

#### [HashMap 和 HashSet 区别]

- 如果你看过 `HashSet` 源码的话就应该知道：`HashSet` 底层就是基于 `HashMap` 实现的。（`HashSet` 的源码非常非常少，因为除了 `clone()`、`writeObject()`、`readObject()`是 `HashSet` 自己不得不实现之外，其他方法都是直接调用 `HashMap` 中的方法
- ![image-20210925224033420](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210925224033420.png)

#### [HashMap 和 TreeMap 区别]

- `TreeMap` 和`HashMap` 都继承自`AbstractMap` ，但是需要注意的是`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口。
- ![image-20210925224424866](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210925224424866.png)
- 实现 `NavigableMap` 接口让 `TreeMap` 有了对集合内元素的**搜索的能力**。
- 实现`SortedMap`接口让 `TreeMap` 有了对集合中的元素根据键**排序的能力**。默认是按 key 的升序排序，
- **相比于`HashMap`来说 `TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力**

#### [ConcurrentHashMap 和 Hashtable 的区别]

- `ConcurrentHashMap` 和 `Hashtable` 的区别主要体现在实现线程安全的方式上不同
  - **底层数据结构：** JDK1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 `HashMap1.8` 的结构一样，数组+链表/红黑二叉树。`Hashtable` 和 JDK1.8 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
  - **实现线程安全的方式（重要）：** ① **在 JDK1.7 的时候，`ConcurrentHashMap`（分段锁）** 对整个桶数组进行了分割分段(`Segment`)，**每一把锁只锁容器其中一部分数据**，多线程访问容器里不同数据段的数据，就不会存在锁竞争，**提高并发访问率**。 **到了 JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 对 `synchronized` 锁做了很多优化）** 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **Hashtable(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入**阻塞或轮询状态**，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。
  - ![image-20210926094129293](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926094129293.png)
  - ![image-20210926094234571](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926094234571.png)
  - ![image-20210926094300189](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926094300189.png)

#### HashMap 的长度为什么是 2 的幂次方

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，**Hash 值的范围值-2147483648 到 2147483647**，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。**用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标**。这个数组下标的计算方法是“ `(n - 1) & hash`”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。

**这个算法应该如何设计呢？**

我们首先可能会想到采用%取余的操作来实现。但是，重点来了：**“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。**

#### HashMap 多线程操作导致死循环问题

主要原因**在于并发下的 Rehash 会造成元素之间会形成一个循环链表**。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如**数据丢失**。**并发环境下推荐使用 ConcurrentHashMap** 。

#### ConcurrentHashMap 线程安全的具体实现方式/底层具体实现

**JDK1.7**首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成。

Segment 实现了 `ReentrantLock`,所以 `Segment` 是一种**可重入锁**，扮演锁的角色。`HashEntry` 用于存储键值对数据。

一个 `ConcurrentHashMap` 里包含一个 `Segment` 数组。`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。

**JDK1.8***`ConcurrentHashMap` 取消了 `Segment` 分段锁，**采用 CAS 和 `synchronized` 来保证并发安全**。数据结构跟 HashMap1.8 的结构类似，**数组+链表/红黑二叉树**。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）

`synchronized` **只锁定当前链表或红黑二叉树的首节点**，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

#### **Map中定义的方法：**

1. **添加、删除、修改操作**：
   1. Object **put**(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
   2. void **putAll**(Map m):将m中的所有key-value对存放到当前map中
   3. Object **remove**(Object key)：移除指定key的key-value对，并返回value
   4. void **clear()**：清空当前map中的所有数据
2. **元素查询的操作：**
   1. Object **get**(Object key)：获取指定key对应的value
   2. boolean **containsKey**(Object key)：是否包含指定的key
   3. boolean **containsValue**(Object value)：是否包含指定的value
   4. int **size()**：返回map中key-value对的个数
   5. boolean **isEmpty()**：判断当前map是否为空
   6. boolean **equals**(Object obj)：判断当前map和参数对象obj是否相等
3. **元视图操作的方法：**
   1. Set **keySet()**：返回所有key构成的Set集合
   2. Collection **values()**：返回所有value构成的Collection集合
   3. Set **entrySet()**：返回所有key-value对构成的Set集合
4. 总结：**常用方法：**
   1. 添加：**put**(Object key,Object value)
   2. 删除：**remove**(Object key)
   3. 修改：**put**(Object key,Object value)
   4. 查询：**get**(Object key)
   5. 长度：**size()**
   6. 遍历：**keySet() / values() / entrySet()**

- **TreeMap**

  向TreeMap中添加key-value，要求key必须是由同一个类创建的对象

  因为要按照key进行排序：**自然排序 、定制排序**

1. **Collections工具类的使用**
   1. Collections:操作Collection、Map的工具类
   2. **面试题：Collection 和 Collections的区别？**
      - **reverse(List)**：反转 List 中元素的顺序
      - **shuffle(List)**：对 List 集合元素进行随机排序
      - sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
      - sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
      - swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
      - Object **max**(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
      - Object **max**(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
      - Object min(Collection)
      - Object min(Collection，Comparator)
      - int **frequency**(Collection，Object)：返回指定集合中指定元素的出现次数
      - void **copy**(List dest,List src)：将src中的内容复制到dest中
      - boolean **replaceAll**(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值
      - **Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题**

### 如何选用集合？

主要根据集合的特点来选用，比如我们需要**根据键值获取到元素值**时就选用 `Map` 接口下的集合，需要**排序时**选择 `TreeMap`,**不需要排序**时就选择 `HashMap`,需要保证**线程安全**就选用 `ConcurrentHashMap`。

当我们只需要**存放元素值**时，就选择实现`Collection` 接口的集合，需要**保证元素唯一时**选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet`，不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList`，然后再根据实现这些接口的集合的特点来选用。

### 无序性和不可重复性的含义？

- 什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在**底层数组中并非按照数组索引的顺序添加** ，而是根据数据的哈希值决定的。
- 什么是不可重复性？不可重复性是指添加的元素按照 **equals()判断时 ，返回 false**，需要同时重写 equals()方法和 HashCode()方法。

### 哈希码

- 在Java中，**哈希码**代表了**对象的一种特征**，例如我们判断某两个字符串是否==，如果其**哈希码相等，则这两个字符串是相等的**。其次，**哈希码是一种数据结构的算法**。常见的哈希码的算法有：
  - 1：**Object类的hashCode**.返回对象的**内存地址经过处理后的结构**，由于**每个对象的内存地址都不一样**，所以哈希码也不一样。
  - 2：String类的hashCode.根据String类包含的字符串的内容，**根据一种特殊算法返回哈希码，只要字符串内容相同，返回的哈希码也相同。**
  - 3：Integer类，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100),i1.hashCode的值就是100 。由此可见，**2个一样大小的Integer对象，返回的哈希码也一样**。


## 泛型

1. 泛型的使用

   - **jdk5.0新增的特性**

   - **集合中使用泛型**

     - 集合接口或集合类在jdk5.0时都修改为带泛型的结构

     - 在实例化集合类时，可以指明具体的泛型类型

     - 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。

       比如：add(E e)  --->实例化以后：add(Integer e)

     - 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换

     - 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。

   - **如何自定义泛型结构：泛型类，泛型接口，泛型方法**

     - **泛型方法**：在方法中出现了泛型的结构，**泛型参数与类的泛型参数没有任何关系。**；换句话说，泛型方法所属的类是不是泛型类都没有关系。**泛型方法，可以声明为静态的**。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。

   - 泛型在继承方面的体现

     - 虽然类A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，二者是并列关系。
     - 补充：类A是类B的父类，A<G> 是 B<G> 的父类

   - **通配符的使用——"?"**

     - 类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是：G<?>

       - 添加(写入)：对于List<?>就不能向其内部添加数据。除了添加null之外。
       - 获取(读取)：允许读取数据，读取的数据类型为Object。

     - **有限制条件的通配符的使用。**

       - ? extends A:

         G<? extends A> 可以作为G<A>和G<B>的父类，其中B是A的子类

       - ? super A:

         G<? super A> 可以作为G<A>和G<B>的父类，其中B是A的父类

## **IO流**

### **File类的使用：**

- File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)

- File类声明在java.io包下

- File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。

- 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的"终点".

- **如何创建File类的实例**

  - File(String filePath)

  - File(String parentPath,String childPath)
  - File(File parentFile,String childPath)

- **路径**

  - 相对路径：相较于某个路径下，指明的路径。
  - 绝对路径：包含盘符在内的文件或文件目录的路径

- **路径分割符**

  - windows:\\\
  - unix:/

- **常用方法**

  | public String getAbsolutePath()：获取绝对路径                |
  | ------------------------------------------------------------ |
  | public String getPath() ：获取路径                           |
  | public String getName() ：获取名称                           |
  | public String getParent()：获取上层文件目录路径。若无，返回null |
  | public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。 |
  | public long lastModified() ：获取最后一次的修改时间，毫秒值  |
  |                                                              |
  | 如下的两个方法适用于文件目录：                               |
  | public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组 |
  | public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组 |
  | public boolean renameTo(File dest):把文件重命名为指定的文件路径 |

  比如：file1.renameTo(file2)为例：要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。

  | public boolean isDirectory()：判断是否是文件目录 |
  | ------------------------------------------------ |
  | public boolean isFile() ：判断是否是文件         |
  | public boolean exists() ：判断是否存在           |
  | public boolean canRead() ：判断是否可读          |
  | public boolean canWrite() ：判断是否可写         |
  | public boolean isHidden() ：判断是否隐藏         |

  创建硬盘中对应的文件或文件目录

  | More Actionspublic boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false |
  | ------------------------------------------------------------ |
  | public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 |
  | public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建 |

  删除磁盘中的文件或文件目录

  | public boolean delete()：删除文件或者文件夹 |
  | ------------------------------------------- |
  | 删除注意事项：Java中的删除不走回收站。      |

### **IO流原理及流的分类**

- **操作数据单位：字节流、字符流**
- **数据的流向：输入流、输出流**
- **流的角色：节点流、处理流**

### 流的体系结构

抽象基类               节点流（或文件流）                                        缓冲流（处理流的一种）

InputStream        FileInputStream   (read(byte[] buffer))        BufferedInputStream (read(byte[] buffer))

OutputStream     FileOutputStream  (write(byte[] buffer,0,len)  BufferedOutputStream (write(byte[] buffer,0,len) / flush()

Reader                  FileReader (read(char[] cbuf))                       BufferedReader (read(char[] cbuf) / readLine())

Writer                   FileWriter (write(char[] cbuf,0,len)                BufferedWriter (write(char[] cbuf,0,len) / flush()

1. **处理流之一：缓冲流的使用**

   - 缓冲流：

   - | BufferedInputStream    |
     | ---------------------- |
     | * BufferedOutputStream |
     | * BufferedReader       |
     | * BufferedWriter       |

     作用：提供流的读取、写入的速度；提高读写速度的原因：**内部提供了一个缓冲区**

     **处理流，就是“套接”在已有的流的基础上。**

2. **处理流之二**：**转换流**

   - 转换流：属于字符流
     - InputStreamReader将一个**字节**的输入流转换为**字符**的输入流
     - OutputStreamWriter将一个**字符**的输出流转换为**字节**的输出流
   - 作用：提供字符流与字节流之间的转换
   - **解码：**字节，字节数组——>字符数组，字符串 
   - **编码**：字符数组，字符串——>字节，字节数组
   - 字符集：
     - ASCII：美国标准信息交换码。用一个字节的7位可以表示。
     - ISO8859-1：拉丁码表。欧洲码表，用一个字节的8位表示。
     - GB2312：中国的中文编码表。最多两个字节编码所有字符
     - GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
     - Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示
     - UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。

3. **其他流**

   - **标准的输入输出流**

     - System.in:标准的输入流，默认从键盘输入
     - System.out:标准的输出流，默认从控制台输出
     - System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。

   - **打印流：PrintStream 和PrintWriter**

     - 提供了一系列重载的print() 和 println()

   - **数据流：DataInputStream 和 DataOutputStream**

     - 作用：用于读取或写出基本数据类型的变量或字符串

   - **对象流**

     - ObjectInputStream 和 ObjectOutputStream

     - 作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。

     - **序列化机制：**

       对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。

     - **自定义类需要满足如下的要求，方可序列化**

       1.需要实现接口：Serializable（这是一个标识接口）

       2.当前类提供一个全局常量：serialVersionUID

       3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）

       ObjectOutputStream和ObjectInputStream不能序列化**static和transient**修饰的成员变量

   - **随机存取文件流**

     - **RandomAccessFile的使用**
       - RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口
       - RandomAccessFile既可以作为一个输入流，又可以作为一个输出流
       - 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。
       - 如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）
       - 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果

   - **jdk 7.0 时，引入了 Path、Paths、Files三个类。**


## 网络编程

1. 网络编程中有两个主要的问题：

   - **如何准确地定位网络上一台或多台主机；定位主机上的特定的应用**
   - **找到主机后如何可靠高效地进行数据传输**

2. 网络编程中的两个要素：

   - 对应问题一：**IP和端口号**
   - 对应问题二：提供网络通信协议：TCP/IP参考模型（**应用层、传输层、网络层、物理+数据链路层**）

3. 通信要素一：IP和端口号

   - IP:唯一的标识 Internet 上的计算机（通信实体）

   - 在Java中使用InetAddress类代表IP

   - IP分类：IPv4 和 IPv6 ; 万维网 和 局域网

   - 域名:   www.baidu.com   www.mi.com  www.sina.com  www.jd.com   www.vip.com

   - 本地回路地址：127.0.0.1 对应着：localhost

   - 如何实例化InetAddress:两个方法：getByName(String host) 、 getLocalHost()

     ​										两个常用方法：getHostName() / getHostAddress()

   - 端口号：正在计算机上运行的进程。要求：不同的进程有不同的端口号；范围：被规定为一个 16 位的整数 0~65535。

   - 端口号与IP地址的组合得出一个网络套接字：Socket


## 反射

1. 反射作用：

   1. 调用类的私有结构：比如私有的**构造器，方法，属性**

2. 疑问

   1. 疑问1：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用那个？

      建议：直接new的方式。

      什么时候会使用：反射的方式。 反射的特征：动态性

   2. 疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？

      不矛盾

3. 关于java.lang.class类的理解

   1. **类的加载过程：**

      程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为**运行时类**，此运行时类，就作为Class的一个实例。

   2. 换句话说，**Class的实例就对应着一个运行时类**

   3. **加载到内存中的运行时类**，会缓存一定的时间。在此时间之内，我们可以通**过不同的方式来获取此运行时类。**

   4. 万事万物皆对象？对象.xxx,File,URL,反射，前端，数据库操作

4. **获取Class的实例的 方式**：

   1. 方式一：**调用运行时类的属性：.class**
   2. 方式二：通过运行时类的**对象,调用getClass()**
   3. 方式三：调用**Class的静态方法：forName(String classPath)**
   4. 使用类的加载器**：ClassLoader  (了解)**

5. **通过反射创建运行时类的对象**

   ​	**newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。**

   ​	 要想此方法正常的创建运行时类的对象，**要求**：

   ​	1.运行时类必须提供**空参的构造器**

   ​	2.空参的构造器的访问权限得够。通常，设置为**public**。

6. 在javabean中要求提供一个**public的空参构造器**。原因：

   1. 便于通过反射，创建运行时类的对象
   2. 便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器

7. **反射的动态性**

8. 通过反射获取运行时类的整体结构

   1. 获取**属性**结构

      **getFields()**:获取当前运行时类及其父类中声明为public访问权限的属性

      **getDeclaredFields()**:获取当前运行时类中声明的所有属性。**（不包含父类中声明的属性）**

   2. 获取**方法**结构

      1. **getMethods()**:获取当前运行时类及其所有父类中声明为public权限的方法
      2. **getDeclaredMethods()**:获取当前运行时类中声明的所有方法。**（不包含父类中声明的方法）**

   3. 获取**构造器**结构

      1. **getConstructors()**:获取当前运行时类中声明为public的构造器
      2. **getDeclaredConstructors()**:获取当前运行时类中声明的所有的构造器

   4. 获取**运行时类的父类**

   5. 获取**运行时类的接口**

   6. 获取运行时类所在的包

9. **调用运行时类的指定结构（属性，方法）**

## Java8新特性

1. **lambda表达式**

   - 举例： (o1,o2) -> Integer.compare(o1,o2);
   - 格式：
     - lambda操作符 或 箭头操作符
     - 左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）
     - 右边：lambda体 （其实就是重写的抽象方法的方法体）
   - Lambda表达式的使用：（分为6种情况介绍）
   - 左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略
   - 右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字
   - Lambda表达式的本质：作为函数式接口的实例
   - 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。
   - 所以以前用**匿名实现类**表示的现在都可以用Lambda表达式来写。

2. **java内置的4大核心函数式接口**

   - 消费型接口 Consumer<T>     void accept(T t)
   - 供给型接口 Supplier<T>     T get()
   - 函数型接口 Function<T,R>   R apply(T t)
   - 断定型接口 Predicate<T>    boolean test(T t)

3. **方法引用和构造器引用**

   - **方法引用**的使用：
     1. 使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！
     2. 方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例
     3. 使用格式：  类(或对象) :: 方法名
     4. 具体分为如下的三种情况：
        - 情况1     对象 :: 非静态方法
        - 情况2     类 :: 静态方法
        - 情况3     类 :: 非静态方法
     5. 方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）
   - **构造器**引用
     - 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。
     - 抽象方法的返回值类型即为构造器所属的类的类型
   - **数组**引用
     - 大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。

4. **强大的StreamAPI**

   1. **Stream**关注的是对数据的运算，与CPU打交道，**集合**关注的是数据的存储，与内存打交道

   2. **Stream 执行流程**

      - Stream的实例化

      - 一系列的中间操作（过滤、映射、...)

      - 终止操作

   3. 说明：

      1.  一个中间操作链，对数据源的数据进行处理
      2.  一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用

   4. 概述

      - Stream 自己**不会存储元素**。
      - Stream 不会**改变源对象**。相反，他们会返回一个持有结果的新Stream。
      - Stream 操作是**延迟执行**的。这意味着他们会等到需要结果的时候才执行

   5. 函数操作：

      1. **映射**
         1. **limit(n)**——截断流，使其元素不超过给定数量。
         2. **skip(n)** —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补
         3. **distinct()**——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素
         4. **map(Function f)**——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。
         5. **flatMap(Function f)**——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。
      2. **排序：**
         1. **sorted()**——自然排序
         2. **sorted(Comparator com)**——定制排序
      3. **Stream的终止操作**
         1. **匹配与查找**
            1. **allMatch(Predicate p)**——检查是否匹配所有元素。
            2. **anyMatch(Predicate p)**——检查是否至少匹配一个元素。
            3. **noneMatch(Predicate p)**——检查是否没有匹配的元素。
            4. **findFirst**——返回第一个元素
            5. **findAny**——返回当前流中的任意元素
            6. **count**——返回流中元素的总个数
            7. **max(Comparator c)**——返回流中最大值
            8. **min(Comparator c)**——返回流中最小值
            9. **forEach(Consumer c)**——内部迭代
         2. **归约**
            1. **reduce(T identity, BinaryOperator)**——可以将流中元素反复结合起来，得到一个值。返回 T
            2. **reduce(BinaryOperator)** ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T>
         3. **收集**

5. **Optional类**

   1.  Optional类：为了在程序中避免出现空指针异常而创建的
   2.  操作：
       1. Optional.of(T t) : 创建一个 Optional 实例，t必须非空；
       2. Optional.empty() : 创建一个空的 Optional 实例
       3. Optional.ofNullable(T t)：t可以为null

# 多线程

1. **程序(program)**是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段**静态的代码，静态对象**。
2. **进程(process)**是**程序的一次执行过程**，或是正在运行的一个程序。是一个动态 的过程：有它自身的**产生、存在和消亡**的过程。——生命周期
   - 程序是静态的，进程是动态的
   - **进程作为资源分配的单位，**系统在运行时会为每个进程分配不同的内存区域
3. **线程(thread)**，进程可进一步细化为线程，是一个程序内部的一条执行路径。
   - 若一个进程同一时间并行执行多个线程，就是支持多线程的
   - **线程作为调度和执行的单位**，每个线程拥有独立的**运行栈**和**程序计数器(pc)**，**线程切换的开 销小**
   - 一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但**多个线程操作共享的系统资 源可能就会带来安全的隐患**

### **多线程的创建和使用**

- **多线程的创建**

  - **方式一：继承于Thread类**

    1. ```
       1. 创建一个继承于Thread类的子类
       2. 重写Thread类的run() --> 将此线程执行的操作声明在run()中
       3. 创建Thread类的子类的对象
       4. 通过此对象调用start()：作用：①启动当前线程②调用当前线程的run()
       ```

  - 创建Thread类的匿名子类的方式

  - **方式二：实现Runnable接口**

    1. 创建一个实现了Runnable接口的类
    2. 实现类中实现Runnable接口中的抽象方法run()
    3. 创建实现类的对象
    4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
    5. 通过Thread类的对象调用start().
       - 启动线程
       - 调用当前线程的run()——>调用了Runnable类型的target的run()

  - **比较两种线程创建方式**

    1. 开发中优先选用实**现Runnable的方法**创建线程
       - 实现的方式**没有类的单继承**的局限性
       - 实现的方式更适合来**处理多个线程有共享数据的情况**
    2. 联系：public   class  Thread  implements  Runnable
    3. 相同点：两种方法都**需要重写run()方法**，将**线程要执行的逻辑声明在run()中。**

- Thread类中常用方法

  - 1、start():启用当前线程：调用当前线程的run();
  - 2、run()：重写Thread类中的此方法，创建的线程要执行的操作声明在此方法中
  - 3、currentThread()：静态方法，**返回执行当前代码的线程**
  - 4、getName():获取当前线程的名字
  - 5、setName():设置当前线程的名字
  - 6、yield():**释放当前线程的执行权**
  - 7、join()**:在线程a中调用线程b的join方法，则线程a阻塞，直到线程b完全执行完以后**，线程a才结束阻塞状态
  - 8、stop（）：**强制线程结束生命周期（已过时**）
  - 9、sleep（long  millitime）：让当前线程睡眠指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程处于阻塞状态
  - 10、isAlive():判断当前线程是否存活

- 线程的优先级

  - ```
    * MAX_PRIORITY：10
    * MIN _PRIORITY：1
    * NORM_PRIORITY：5  -->默认优先级
    ```

  - 如何获取和设置当前线程的优先级：

    1. getPriority():获取线程的优先级
    2. setPriority():设置线程的优先级
    3. **高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲**，高优先级的线程高概率的情况下执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。

### **线程的生命周期**

1. ![image-20210817091413948](file://C:/Users/17391/AppData/Roaming/Typora/typora-user-images/image-20210817091413948.png?lastModify=1635233823)

### 线程的同步

1. 在Java中通过同步机制，解决线程的安全问题
2. **方式一同步代码块**
   - **synchronized(同步监视器){//需要被同步的代码}**
   - **操作共享数据的代码，即为需要被同步的代码**——>不能包含代码多了，也不能包含代码少了
   - 共享数据：多个线程共同
   - **同步监视器**：俗称**锁**任何一个类的对象都可以充当锁
   - 要求：多个线程必须要共用同一把锁。
   - 在实现Runnable接口创建多线程的方式中，可以考虑使用this充当同步监视器
3. **方式二同步方法**
   - 如果操作共享数据的代码完整的声明在一个方法中，我们将此方法声明同步的。
   - 同步方法仍然涉及到同步监视器，只是不需要显式的声明
   - 非静态的同步方法，同步监视器是this
   - **静态的同步方法，同步监视器是：当前类本身**
4. 同步的方式，解决了线程的安全问题。--**好处**；操作同步代码时，只能一个线程参与，其它线程等待，相当于一个单线程的过程，效率低

### 线程的死锁

1. 死锁的理解：不同的线程占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
2. 说明：
   - 出现死锁后不会出现异常，不会出现提示，只是所有的线程处于阻塞状态，无法继续
   - 使用同步时，避免出现死锁
3. 条件：
   1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
   2. **请求与保持条件：**一个进程因请求资源而阻塞时，对已获得的资源保持不放。
   3. **不剥夺条件**:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
   4. **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。

- 解决线程安全问题的方式三：**Lock锁**    ------JDK5.0新增
  1. 实例化ReentrantLock
  2. 调用锁定方法lock();
  3. 调用解锁方法unlock();

### **synchronized和lock的异同？**

- 都可以**解决线程安全问题**

- synchronized机制在执行完相应的同步代码以后，**自动释放**同步监视器：Lock需要手动的启动同步（Lock()）**手动结束**同步（unlock()）;

- 优先使用顺序：

  ①**Lock（）**②**同步代码块已经进入了方法体，分配了相应资源**）③**同步方法（在方法体外）**

- **如何解决线程安全问题？有几种方式**

  - 三种方式

### **线程的通信**

- 三种方法：
  1. **wait():**一旦执行此方法，当前线程进入阻塞状态，并释放同步监视器
  2. **notify():**执行此方法，就会唤醒被wait()的线程，若有多个线程，唤醒优先级最高的线程
  3. **notifyAll():**唤醒所有被wait()的线程。
- 三种方法必须使用在**同步代码块或同步方法中**
- 三个方法的**调用者**，必须是**同步代码块或同步方法中的同步监视器**；否则会出现**IllegalMonitorstateException**异常
- 三个方法定义在java.lang.Object类中

### **sleep（）和wait()方法的异同**

- 相同点:一旦执行方法，都可以是当前线程进入**阻塞状态**
- 不同点：
  - 声明的位置不同：**Thread类中声明sleep()方法**；Object类中声明wait()方法
  - 调用的范围不同：sleep()可以在任何需要的场景下调用。**wait()必须使用在同步代码块或同步方法中**
  - **关于是否释放同步监视器**：如果两个方法都使用在同步代码块或同步方法中，sleep()**不会释放锁**，wait（）会释放锁

### JDK5.0新增线程创建方式

1. 方式一：**实现Callable接口**
   - 相比**run()方法，可以有返回值**
   - 方法**可以抛出异常**
   - 支持**泛型的返回值**
   - 需要借助**FutureTask类，比如获取返回结果**
2. 方式二：**使用线程池**
   1. 好处：
      - **提高响应速度（减少创建新线程时间）**
      - **降低资源消耗**（**重复利用线程池中线程**，不需要每次都创建）
      - **便于线程管理**
        - **corePoolSize**:核心池的大小，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中
        - **maximumPoolSize**:最大线程数，**核心线程数+非核心线程数=最大线程数**
        - **keepAliveTime**:线程没有任务时最多保持多长时间后会终止
        - **workQueue**工作队列
          1. **ArrayBlockingQueue** ：是由**数组实现的有界的阻塞队列**，在初始化的时候，必须指定大小。
          2. **LinkedBlockingQueue** ：是由**链表实现的无界的阻塞队列**，默认是Integer.MAX_VALUE，也可以初始化的时候指定大小。
          3. **DelayQueue**：**延迟队列**，只有延迟期满足才会从队列中获取元素。
          4. **SynchronousQueue**：**是一个不存储元素的阻塞队列**。若是插入的时候，已经有一个元素，就会阻塞等待，直到这个元素被移除，反之亦然。
          5. **LinkedBlockingDeque**：**是一个由链表组成的双向阻塞队列**。
        - **unit**：**空闲时间的单位**
        - **threadFactory**：从名字来看是**线程工厂**，主要是给线程一个标识
        - **handler**：这个就是拒绝策略
          1. **DiscardPolicy**：直接丢弃任务，不做处理，不抛出异常，一般是对应无关紧要的任务。
          2. **DiscardOldestPolicy**：丢弃队列中最前面的任务，也就是最老的任务，然后尝试执行新任务。
          3. **CallerRunsPolicy**：由调用者线程进行处理。
          4. **AbortPolicy**：抛出异常。
3. 一个Java应用程序java.exe,其中至少有三个线程：**main()主线程，gc()垃圾回收线程，异常处理线程**。如果发生异常，会影响主线程。

### 上下文切换

**多线程编程中一般线程的个数都大于 CPU 核心的个数**，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，**CPU** 采取的策略是**为每个线程分配时间片并轮转的形式**。当一个线程的时间片用完的时候就会重新处于**就绪状态**让给其他线程使用，这个过程就属于一次**上下文切换**。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会**先保存自己的状态**，以便下次再**切换回这个任务时**，可以**再加载这个任务的状态**。**任务从保存到再加载的过程就是一次上下文切换**。

上下文切换通常是**计算密集型**的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，**上下文切换对系统来说意味着消耗大量的 CPU 时间**，事实上，可能是操作系统中时间消耗最大的操作。

Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。



# Java虚拟机（JVM）

## Java内存区域详解

### 概述

对于 Java 程序员来说，在**虚拟机自动内存管理机制**下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，**不容易出现内存泄漏和内存溢出**问题。正是因为 **Java 程序员把内存控制权利交给 Java 虚拟机**，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务

### 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域

**线程私有的：**程序计数器，虚拟机栈，本地方法栈；**线程共享的：**堆空间，方法区，直接内存

#### 程序计数器

程序计数器是一块较小的内存空间，可以看作是**当前线程所执行的字节码的行号指示器**。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

#### Java虚拟机栈

与程序计数器一样，Java 虚拟机栈也是**线程私有**的，它的生命周期和线程相同，描述的是 **Java 方法执行的内存模型**，每次方法调用的数据都是通过栈传递的。

Java 内存可以粗糙的区分为**堆内存（Heap）和栈内存 (Stack)**，其中栈就是现在说的**虚拟机栈**，或者说是**虚拟机栈中局部变量表部**分。 （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译期可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个**指向对象起始地址的引用指针**，也可能是指向一个**代表对象的句柄**或**其他与此对象相关的位置**）。

**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程**请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候**，就抛出 StackOverFlowError 错误。
- **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

Java 栈可以类比数据结构中**栈**，Java 栈中保存的主要内容是**栈帧**，**每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。**

Java 方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出。

#### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的**局部变量表、操作数栈、动态链接、出口信息**。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

#### 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 **JIT 编译器的发展与逃逸分析技术**逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，**如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。**

Java 堆是**垃圾收集器管理**的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：**Eden 空间、From Survivor、To Survivor 空**间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

在 **JDK 7 版本及 JDK 7 版本**之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

**JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。**

大部分情况，**对象都会首先在 Eden 区域分配**，**在一次新生代垃圾回收后**，**如果对象还存活，则会进入 s0 或者 s1**，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，**当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中**。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

**Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值**

堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：

1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`** ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. **`java.lang.OutOfMemoryError: Java heap space`** :假如在**创建新的对象时, 堆内存中的空间不足以存放新创建的对象**, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值，详见：[Default Java 8 max heap size](https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size))

#### 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

方法区也被称为永久代

##### 方法区与永久代的关系

《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

##### 常用参数

**JDK 1.8 之前**永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGenCopy to clipboardErrorCopied
```

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

**JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（**JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

下面是一些常用参数：

```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小Copy to clipboardErrorCopied
```

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

##### 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

1. **整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整**，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

   > 当元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`

你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

1. **元空间里面存放的是类的元数据**，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
2. **在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西**, 合并之后就没有必要额外的设置这么一个永久代的地方了。

#### 运行时常量池

**运行时常量池是方法区的一部分**。**Class 文件中除了有类的版本、字段、方法、接口**等描述信息外，还有**常量池表**（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池是方法区的一部分，**自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误**。

> **🐛 修正（参见：[issue747](https://github.com/Snailclimb/JavaGuide/issues/747)，[reference](https://blog.csdn.net/q5706503/article/details/84640762)）** ：
>
> 1. **JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代**
> 2. **JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代** 。
> 3. **JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)**

## JVM垃圾回收https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6

### 收集算法

1. **标记清除**算法

   首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象，

   1. **效率问题**
   2. **空间问题（标记清除后会产生大量不连续的碎片）**

2. **标记复制**算法

   **它可以将内存分为大小相同的两块**，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

3. **标记整理**算法

   根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，**而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。**

4. **分代收集**算法

   当前**虚拟机的垃圾收集都采用分代收集算法**，这种算法没有什么新的思想，**只是根据对象存活周期的不同将内存分为几块**。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

   **比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集**

### 垃圾收集器

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**

1. ### Serial 收集器

   S**erial（串行）收集器是最基本、历史最悠久的垃圾收集器了**。大家看名字就知道这个收集器是一个**单线程收集器**了。它的 **“单线程”** 的意义不仅仅意味着它只会**使用一条垃圾收集线程去完成垃圾收集工作**，更重要的是它在进行垃圾收集工作的时候**必须暂停其他所有的工作线程**（ **"Stop The World"** ），直到它收集结束。

   简单高效

2. ### **ParNew收集器**

   **ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**

3. ### **ParallelScavenge收集器**

   Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器

   **Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

4. ### **Serial Old收集器**

   **Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案

5. ### **Parallel Old收集器**

   **Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

6. ### **CMS收集器**

   **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

   **CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作**

7. ### **G1收集器**

   **G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

   被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

   - **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
   - **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
   - **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
   - **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，**降低停顿时间是 G1 和 CMS 共同的关注点**，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

   G1 收集器的运作大致分为以下几个步骤：

   - **初始标记**
   - **并发标记**
   - **最终标记**
   - **筛选回收**

   **G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

8. ### **ZGC收集器**

   与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用**标记-复制算法**，不过 ZGC 对该算法做了重大改进。

   在 ZGC 中出现 Stop The World 的情况会更少！

### 判断对象已经死亡

#### 引用计数法

**给对象中添加一个引用计数器**，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

简单高效

很难解决**对象之间相互循环引用**的问题

#### 可达性分析

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点**开始向下搜索**，**节点所走过的路径称为引用链**，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

可作为 GC Roots 的对象包括下面几种:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中**类静态属性**引用的对象
- 方法区中**常量**引用的对象
- **所有被同步锁持有的对象**

### 引用

无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。

JDK1.2 之前，Java 中引用的定义很传统：如果 **reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。**

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为**强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）**

**1.强引用（StrongReference）**

以前我们使用的**大部分引用实际上都是强引用**，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，**垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止**，也不会靠随意回收具有强引用的对象来解决内存不足问题。

**2．软引用（SoftReference）**

如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果**内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存**。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来**实现内存敏感的高速缓存**。

软引用可以和一个**引用队列（ReferenceQueue）**联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

**3．弱引用（WeakReference）**

如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：**只具有弱引用的对象拥有更短暂的生命周期**。在垃圾回收器线程扫描它所管辖的内存区域的过程中，**一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

**4．虚引用（PhantomReference）**

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，**虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**

**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

# Linux五大网络IO模型

[长知识！详解Linux五大网络IO模型 (qq.com)](https://mp.weixin.qq.com/s/ajuk5P4cV5pPTIpeRGg0Rg)

## 阻塞/非阻塞与同步/异步

### **阻塞/非阻塞**

> 针对的对象是**调用者自己本身**的情况

####  阻塞

指**调用者**在调用某一个函数后，一直在等待该函数的返回值，线程处于**挂起**状态。

#### 非阻塞

指调用者在调用某一个函数后，不等待该函数的返回值，线程继续运行其他程序（执行其他操作或者一直遍历该函数是否返回了值）

### **同步/异步**

> 针对的对象是**被调用者的情况**

#### 同步

指的是被调用者在被调用后，操作完函数所包含的所有动作后，再返回返回值

#### 异步

指的是被调用者在被调用后，先返回返回值，然后再进行函数所包含的其他动作。

# 常用框架

## Spring，SpringMVC，SpringBoot，SpringCloud 有什么区别和联系？

**简单介绍**

Spring是一个**轻量级的控制反转(IoC)和面向切面(AOP)的[容器](https://cloud.tencent.com/product/tke?from=10680)框架**。Spring使你能够编写更干净、更可管理、并且更易于测试的代码。

**Spring MVC是Spring的一个模块**，一个web框架。通过**Dispatcher Servlet, ModelAndView 和 View Resolve**r，开发web应用变得很容易。主要针对的是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。

**Spring配置复杂，繁琐，所以推出了Spring boot，约定优于配置，简化了spring的配置流程**。

Spring Cloud构建于Spring Boot之上，是一个关注全局的服务治理框架。

### **Spring VS SpringMVC：**

Spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；

SpringMVC是Spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于Spring框架中WEB层开发的一部分；

### **SpringMVC VS SpringBoot：**

**SpringMVC属于一个企业WEB开发的MVC框架**，涵盖面包括**前端视图开发、文件配置、后台接口逻辑开发**等，XML、config等配置相对比较繁琐复杂；

SpringBoot框架相对于SpringMVC框架来说，**更专注于开发微服务后台接口，不开发前端视图**；

### **SpringBoot和SpringCloud：**

**SpringBoot使用了默认大于配置的理念**，集成了快速开发的Spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，**能快速开发单个微服务**；

SpringCloud大部分的功能插件都是基于SpringBoot去实现的，SpringCloud关注于全局的微服务整合和管理，将多个SpringBoot单体微服务进行整合以及管理；SpringCloud依赖于SpringBoot开发，而SpringBoot可以独立开发；

### **总结下来：**

- Spring是核心，提供了基础功能；
- Spring MVC 是基于Spring的一个 MVC 框架 ；
- Spring Boot 是为简化Spring配置的快速开发整合包；
- Spring Cloud是构建在Spring Boot之上的服务治理框架。
