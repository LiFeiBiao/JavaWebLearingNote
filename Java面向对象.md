#### Java面向对象

##### 三条主线

1. Java类和类的成员：属性，方法，构造器，代码块，内部类

2. 面向对象的三大特征：封装，继承，多态（抽象性）

3. 其他关键字：this,super,static,final,abstract,interface,package,import

   

##### 面向对象两个要素 

1. 类：对一类事物的描述，是抽象的概念上的定义
2. 对象，是实际存在的该类事物的每个个体，因而也成为实例（instance）
3. 面向对象程序设计的重点是**类的设计**，设计类，就是设计类的成员。

##### Java类和类的成员

1. 属性：对应类中的成员变量
2. 方法：对应类中的成员方法（函数）
3. 类的实例化就是创建对象

##### 类和对象的使用（面向对象思想落地实现）

1. 创建类，设计类的成员
2. 创建类的对象
3. 通过“对象.属性”或"对象.方法"调用对象结构

![image-20210725093122954](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210725093122954.png)

##### 内存解析

1. **堆(Heap)** ,此内存区域的唯一目的就是**存放对象实例**,几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。
2. **栈(Stack)** ,是指虚拟机栈。虚拟机栈用于**存储局部变量**等。局部变量表存放了编译期可知长度的各种基本数据类型(boolean, byte.char、 short、 int、 float、 long、double) 、对象引用(reference类型,它不等同于对象本身,是对象在堆内存的首地址)。方法执行完, 自动释放。
3. **方法区(Method Area)** ,用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码等**数据。
4. 编译完源程序以后，生成一个或多个字节码文件，使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行，意味着将字节码文件对应的类加载到内存中，涉及到内存解析

##### 内存解析的说明

1. 引用类型的变量，只能存储两类值：**null**或**地址值** 	（含变量的类型 ）

##### 类中属性的使用

1. 属性（成员变量）和局部变量
   - 相同点：
     1. 定义变量的格式：数据类型 变量名 = 变量值
     2. 先声明，后使用
     3. 变量都有其对应的作用域
   - 不同点：
     1. <u>在类中声明的位置不同</u>，**属性（成员变量）**直接定义在类的一对{}中；**局部变量**声明在方法内，代码块内，构造器形参，构造器内部的变量
     2. <u>关于权限修饰符</u>，**属性（成员变量）**可以在声明属性时，指明其权限，使用权限修饰符。**局部变量**不使用权限修饰符
     3.  **常用权限修饰符**：**private,public,缺省，protected**
     4. **默认初始化值**：**属性：**类的属性，根据其类型，都有默认初始化值；**局部变量：**<u>没有默认初始化值，定义时必须赋值</u>，形参在方法调用时赋值即可。
     5. 内存中加载的位置：**属性（成员变量）**：加载到**堆空间**中，**局部变量**在**栈**中

##### 类中方法的使用

1. 方法：描述类该有的功能

2. 方法的声明：权限修饰符  返回值类型  函数名（形参列表）{

   ​                          						方法体

   ​						}

3. 说明：

   1. 关于权限修饰符，默认方法的权限修饰符先都使用public
   2. 返回值类型：有返回值和无返回值
      - 有返回值，必须在方法声明时，指定返回值的类型，同时在方法中需使用return返回指定数据类型的变量或常量；如没有返回值，则在方法声明时使用void来表示。

4. 方法名：属于标识符，命名规范，见名知意

5. 形参列表：方法可以声明0个，1个，或者多个。格式：数据类型1 形参1，数据类型2，形参2，……

6. 方法体：方法功能的体现

7. 方法的使用中，可以调用当前类的属性和方法

##### return关键字的使用 

1. 使用范围：使用在方法体中
2. **作用**：结束方法，针对有返回值的方法，使用**”return数据“**返回所需数据
3. 注意点：return关键字后面不可以声明执行语句

##### 匿名对象的使用

1. 格式：**new 对象名（）.方法名或属性名**
2. 理解：创建的对象，没有显示的赋给一个变量名，即为匿名对象
3. 特征：匿名对象只能使用一次

##### 理解"万事万物皆对象"

1. 在java语言范畴中，我们都将功能，结构等封装到类中，通过类的实例化，来调用具体的功能结构
   - Scanner，String，等
   - 文件：File
   - 网络资源：URL
2. 涉及到Java语言与前端Html，后端的数据交互时，前后端的结构Java层面交互时，都体现为类，对象

##### 方法的重载

1. 定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可
   - "两同一不同"：同一个类，相同方法名；参数列表不同，参数个数不同，参数类型不同
2. 举类：Array类中重载的sort()/binarySearch()
3. 判断是否重载
   - 跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系

##### 可变个数的形参

1. jdk5.0新增的内容
2. 具体使用
   - 可变个数形参的格式：数据类型... 变量名
   - 当调用可变个数形参的方法时，传入的参数个数可以时0个，1个，或者多个
3. 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
4. 可变个数形参的方法与本类中方法名相同，形参类型也相同的**数组**之间不构成重载，换句话说“二者不能同时存在”
5. 可变个数形参在方法的形参中，必须声明在末尾
6. 可变个数形参在方法的形参中，最多只能声明一个可变形参。

##### 方法参数的值传递机制

1. 形参:方法声明时的参数
2. 实参：方法调用时实际传给形参的参数值
3. 值传递机制
   - 如果参数时基本数据类型，此时赋值（实参赋给形参）的是（实参）所保存的数据值
   - 如果参数是引用数据类型，此时赋值（实参赋给形参）的是实参所保存的数据的地址值

##### 递归方法的使用

1. 递归方法：一个方法体内调用它自身
2. 方法递归包含了隐式的循环，它会重复执行某行代码，但这种重复执行无需循环控制，递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

##### 封装与隐藏

1. 问题的引入
   - 当创建一个类的对象以后，可以通过“对象.属性”的方式，对对象的属性进行赋值，受属性的数据类型和存储范围的制约，除此之外，没有其他制约条件。在实际问题中，往往需要给属性添加额外的限制条件，这个条件不能在属性声明时体现 ，只能通过方法进行制约条件的添加（比如**set方法**），同时，避免用户在使用“**对象.属性**”对属性进行赋值。则需要将属性声明为私有的（**private**）。
   - 此时针对于属性就体现了**封装性**
2. 封装性的体现：将类的属性（xxx)私有化（private），同时，提供公共的（public）方法来获取（getxxx）和设置（setxxx）此属性的值
3. 拓展：封装性的体现：1、如上；2、不对外暴露的私有的方法；3、单例模式