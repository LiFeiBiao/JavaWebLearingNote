#### Java面向对象

##### 三条主线

1. Java类和类的成员：属性，方法，构造器，代码块，内部类

2. 面向对象的三大特征：封装，继承，多态（抽象性）

3. 其他关键字：this,super,static,final,abstract,interface,package,import

   

##### 面向对象两个要素 

1. 类：对一类事物的描述，是抽象的概念上的定义
2. 对象，是实际存在的该类事物的每个个体，因而也成为实例（instance）
3. 面向对象程序设计的重点是**类的设计**，设计类，就是设计类的成员。

##### Java类和类的成员

1. 属性：对应类中的成员变量
2. 方法：对应类中的成员方法（函数）
3. 类的实例化就是创建对象

##### 类和对象的使用（面向对象思想落地实现）

1. 创建类，设计类的成员
2. 创建类的对象
3. 通过“对象.属性”或"对象.方法"调用对象结构

![image-20210725093122954](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210725093122954.png)

##### 内存解析

1. **堆(Heap)** ,此内存区域的唯一目的就是**存放对象实例**,几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配。
2. **栈(Stack)** ,是指虚拟机栈。虚拟机栈用于**存储局部变量**等。局部变量表存放了编译期可知长度的各种基本数据类型(boolean, byte.char、 short、 int、 float、 long、double) 、对象引用(reference类型,它不等同于对象本身,是对象在堆内存的首地址)。方法执行完, 自动释放。
3. **方法区(Method Area)** ,用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码等**数据。
4. 编译完源程序以后，生成一个或多个字节码文件，使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行，意味着将字节码文件对应的类加载到内存中，涉及到内存解析

##### 内存解析的说明

1. 引用类型的变量，只能存储两类值：**null**或**地址值** 	（含变量的类型 ）

##### 类中属性的使用

1. 属性（成员变量）和局部变量
   - 相同点：
     1. 定义变量的格式：数据类型 变量名 = 变量值
     2. 先声明，后使用
     3. 变量都有其对应的作用域
   - 不同点：
     1. <u>在类中声明的位置不同</u>，**属性（成员变量）**直接定义在类的一对{}中；**局部变量**声明在方法内，代码块内，构造器形参，构造器内部的变量
     2. <u>关于权限修饰符</u>，**属性（成员变量）**可以在声明属性时，指明其权限，使用权限修饰符。**局部变量**不使用权限修饰符
     3.  **常用权限修饰符**：**private,public,缺省，protected**
     4. **默认初始化值**：**属性：**类的属性，根据其类型，都有默认初始化值；**局部变量：**<u>没有默认初始化值，定义时必须赋值</u>，形参在方法调用时赋值即可。
     5. 内存中加载的位置：**属性（成员变量）**：加载到**堆空间**中，**局部变量**在**栈**中

##### 类中方法的使用

1. 方法：描述类该有的功能

2. 方法的声明：权限修饰符  返回值类型  函数名（形参列表）{

   ​                          						方法体

   ​						}

3. 说明：

   1. 关于权限修饰符，默认方法的权限修饰符先都使用public
   2. 返回值类型：有返回值和无返回值
      - 有返回值，必须在方法声明时，指定返回值的类型，同时在方法中需使用return返回指定数据类型的变量或常量；如没有返回值，则在方法声明时使用void来表示。

4. 方法名：属于标识符，命名规范，见名知意

5. 形参列表：方法可以声明0个，1个，或者多个。格式：数据类型1 形参1，数据类型2，形参2，……

6. 方法体：方法功能的体现

7. 方法的使用中，可以调用当前类的属性和方法

##### return关键字的使用 

1. 使用范围：使用在方法体中
2. **作用**：结束方法，针对有返回值的方法，使用**”return数据“**返回所需数据
3. 注意点：return关键字后面不可以声明执行语句

##### 匿名对象的使用

1. 格式：**new 对象名（）.方法名或属性名**
2. 理解：创建的对象，没有显示的赋给一个变量名，即为匿名对象
3. 特征：匿名对象只能使用一次

##### 理解"万事万物皆对象"

1. 在java语言范畴中，我们都将功能，结构等封装到类中，通过类的实例化，来调用具体的功能结构
   - Scanner，String，等
   - 文件：File
   - 网络资源：URL
2. 涉及到Java语言与前端Html，后端的数据交互时，前后端的结构Java层面交互时，都体现为类，对象

##### 方法的重载

1. 定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可
   - "两同一不同"：**同一个类，相同方法名**；参数列表不同，**参数个数不同，参数类型不同**
2. 举类：Array类中重载的sort()/binarySearch()
3. 判断是否重载
   - 跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系

##### 可变个数的形参

1. jdk5.0新增的内容
2. 具体使用
   - 可变个数形参的格式：数据类型... 变量名
   - 当调用可变个数形参的方法时，传入的参数个数可以时0个，1个，或者多个
3. 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
4. 可变个数形参的方法与本类中方法名相同，形参类型也相同的**数组**之间不构成重载，换句话说“二者不能同时存在”
5. 可变个数形参在方法的形参中，必须声明在末尾
6. 可变个数形参在方法的形参中，最多只能声明一个可变形参。

##### 方法参数的值传递机制

1. 形参:方法声明时的参数
2. 实参：方法调用时实际传给形参的参数值
3. 值传递机制
   - 如果参数时基本数据类型，此时赋值（实参赋给形参）的是（实参）所保存的数据值
   - 如果参数是引用数据类型，此时赋值（实参赋给形参）的是实参所保存的数据的地址值

##### 递归方法的使用

1. 递归方法：一个方法体内调用它自身
2. 方法递归包含了隐式的循环，它会重复执行某行代码，但这种重复执行无需循环控制，递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

##### 封装与隐藏

1. 问题的引入
   - 当创建一个类的对象以后，可以通过“对象.属性”的方式，对对象的属性进行赋值，受属性的数据类型和存储范围的制约，除此之外，没有其他制约条件。在实际问题中，往往需要给属性添加额外的限制条件，这个条件不能在属性声明时体现 ，只能通过方法进行制约条件的添加（比如**set方法**），同时，避免用户在使用“**对象.属性**”对属性进行赋值。则需要将属性声明为私有的（**private**）。
   - 此时针对于属性就体现了**封装性**
2. 封装性的体现：将类的属性（xxx)私有化（private），同时，提供公共的（public）方法来获取（getxxx）和设置（setxxx）此属性的值
3. 拓展：封装性的体现：1、如上；2、不对外暴露的私有的方法；3、单例模式

##### 为什么需要封装，封装的作用和含义？

1. 程序设计追求“高内聚,低耦合”。>**高内聚**:类的内部数据操作细节自己完成,不允许外部干涉;>**低耦合**:仅对外暴露少量的方法用于使用。
2. 隐藏对象内部的复杂性,只对外公开简单的接口。便于外界调用,从而**揚高系统的可扩展性、可维护性**。通俗的说,把该隐藏的隐藏起来,该暴露的暴露出来。这就是封装性的设计思想。

##### 封装性的体现，需要权限修饰符配合

1. Java规定的四种权限关键字（从小到大排列）：**private，缺省，protected，public**
2. 对于**class**的权限修饰只可以用**public和defaul(缺省)**。
3. **public类**可以在**任意地方**被访问。**default类**只可以被**同一个包内部的类**访问。
4. 可以用来修饰类和类的内部结构：属性，方法，构造器，内部类

![image-20210727092118202](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210727092118202.png)

##### 封装性的体现

1. Java提供了四种权限修饰符来修饰类和类的内部结构，体现类和类的内部结构在被调用时可见性的大小

##### 构造器（构造方法，constructor）的使用

1. **构造器的作用**
   - 创建对象
   - 初始化对象的属性
2. **说明**
   - 如果没有显示的定义类的构造器，则系统默认提供一个空参构造器
   - 定义构造器的格式：**权限修饰符  类名（参数列表）{}** 
   - 一个类中定义的多个构造器，彼此之间构成**重载**
   - 一旦显示的定义了类的构造器，系统就不再提供默认的空参构造器
   - 一个类中至少要有一个构造器
3. **属性赋值的先后顺序**
   - ①默认初始化值
   - ②显示初始化/⑤代码块中赋值
   - ③构造器中赋值
   - ④通过“对象.方法”和“对象.属性”进行赋值
   - 操作顺序① - ②/⑤ - ③ - ④ 

##### JavaBean

1. JavaBean是一种lava语言写成的可重用组件
2. 所谓JavaBean,是指符合如下标准的Java类:
   - 类是公共的
   - 有一个无参的公共的构造器
   - 有属性,且有对应的get, set方法
3. 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包,并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean, applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能,而不用关心任何改变。

##### this关键字的使用

1. this可以用来修饰属性，方法，构造器
2. this修饰属性和方法，this理解为当前对象,通常情况下选择二省略“this”，特殊情况下，如果方法的形参和类的属性同名时，必须显式的使用“this.属性”的方式，表明此变量是属性，不是形参。
3. this.age=age this表示该类的一个对象，this.age成员变量
4. this(age)；该类的构造器
   - 在类的构造器中，可以显式的使用“this（参数列表）”方式，调用本类中指定的其他构造器
   - 构造器中不能使用“this（参数列表）”方式调用自己
   - 如果一个类中有n个构造器，则最多有n-1个构造器中使用了“this（参数列表）”
   - 规定：“this（参数列表）”必须声明在当前构造器的首行
   - 构造器内部，最多只能声明一个“this（参数列表）”，调用其他构造器

##### package，import关键字的使用

1. **package关键字的使用**
   - 为了更好的实现项目中类的管理，提供包的概念
   - 使用**package**声明**类或接口**所属包，声明在源文件的**首行**
   - 包名：属于标识符，全部小写，规范“见名知意”
   - 每“。”一次，就代表一层文件目录
   - 同一个包下，不可以命名同名的接口和类
2. **import关键字的使用**
   - 在源文件中显示的使用import结构导入指定包下的类，接口
   - 声明在包和类的声明之间
   - 如果需要导入多个结构，则并列写出即可
   - 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
   - 如果使用的类或接口是本包下定义的，可以省略import
   - 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。
   - import  static：导入指定类或接口中的静态结构：属性，方法

![image-20210727132402187](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210727132402187.png)

##### 继承性

1. 好处
   - 减少代码冗余，提高代码复用性
   - 便于功能的扩展
   - 为之后多态性的使用，提供了前提
2. 格式
   - class A extends B{}
   - A子类，派生类 subclass
   - B父类，超类，基类supercla
   - 体现：一旦A继承B后，子类A获取了父类B声明的结构：方法，属性；特别的，父类中声明的私有（private）的属性和方法，子类继承之后，仍然获取了父类中私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。
   - 子类继承父类以后，可以声明定义自己特有的方法和属性
   - 子类和父类的关系，不同于子集和集合的关系
3. 规定：
   - 一个类可以被多个子类继承
   - 一个类只能有一个父类
   - 子父类是相对的概念。
   - 子类直接继承的父类，称为直接父类，间接继承的父类称为间接父类
   - 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法
   - **同名同类型属性不会被覆盖**
4. object类
   - 如果没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类
   - 所有的类都直接或间接继承于Object类
   - 所有Java类都具有java.lang.Object类声明的功能

##### 方法的重写（override,overwrite)

1. 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
2. 应用：重写以后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法
3. 重写的规定：
   - **方法的声明**：权限修饰符  返回值类型  方法名（参数列表）throws	异常类型{方法体}
   - 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
   - 子类重写的方法的**方法名和形参列表**与父类被重写的方法的方法名和形参列表**相同**
   - 子类重写的方法的**权限修饰符不小于**父类被重写的方法的权限修饰符
   - **特殊情况**：子类中不能重写父类中声明为**private权限**的方法
   - 返回值类型：
     1. 父类被重写的方法的返回值类型是**void**，则子类重写的方法的返回值类型也只能是**void**
     2. 父类被重写的方法的返回值类型是**A类**，则子类重写的方法的返回值类型可以是**A类或A类的子类**
     3. 父类被重写的方法的返回值类型是**基本数据类型**，则子类重写的方法的返回值类型必须是相同的基本数据类型
     4. 子类重写方法抛出的**异常类型不大于**父类被重写的方法抛出的异常类型
   - 子类和父类中同名同参数的方法要么都声明为**非static的（考虑重写）**，要么都声明为static的（不是重写）。

##### super关键字

1. super理解为：父类的
2. super可以用来调用属性，方法，构造器
3. 使用：
   - 可以在子类的方法或构造器中，通过使用“super.属性”和“super.方法”的方式，显式的调用父类中声明的属性或方法，通常情况下，习惯省略“super”
   - 特殊情况：当子类中定义了和父类中同名的属性时，要想再子类中调用父类中的同名属性，必须显式的使用“super.属性”的方式，表明调用的是父类中声明的属性
   - 特殊情况，当子类中重写了父类的方法后，想在子类中调用父类中被重写的方法时，必须显式的使用“super.方法”的方式，表明调用的是父类中声明的方法
   - 
4. super调用构造器
   - 可以在子类的构造器中显式的使用“super（形参列表）”的方式，调用父类中声明的指定的构造器
   - “super（形参列表）”的使用，必须声明在子类构造器方法体的首行
   - 在类的构造器中，针对于“this（形参列表）”或“super（形参列表）”只能二选一，不能同时出现
   - 在构造器的首行，没有显式的声明“this（形参列表）”或“super（形参列表）”，则默认调用的是父类中空参的 构造器
   - 在类的多个构造器中至少有一个构造器使用了“super（形参列表）”，调用父类中的构造器

##### 子类对象实例化的全过程

1. 从结果上看（继承性）
   - 子类继承父类以后，就获取了父类中声明的属性和方法
   - 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
2. 从过程上看:
   - 通过子类构造器创建子类对象时，一定会直接或间接的调用父类的构造器，进而调用父类的父类的构造器，直到调用java.lang.Object类中空参的构造器为止，因为加载过所有的父类结构，才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
3. 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new()的子类对象

##### 多态性

1. 可以理解为一个事物得多种形态
   - **对象的多态性**：父类的引用指向子类的对象（或者子类的对象赋给父类的引用)
   - 多态的使用;当调用子父类同名同参数的方法时，实际**执行的是子类重写父类的方法**--------**虚拟方法调用**
2. 多态的使用，虚拟方法调用
   - 有了对象的多态性后，在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法
   - **编译：看左边，执行：看右边**
3. 多态性的使用前提：
   - **类的继承关系**
   - **方法的重写**
4. 对象的多态性，只适用于方法，不适用属性**（编译和运行都看左边）**
5. **虚拟方法调用**
   - 子类中定义了与父类同名同参数的方法,在多态情况下,将此时父类的方法称为**虚拟方法**,父类根据赋给它的不同子类对象,动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
   - 编译时类型和运行时类型
     - **动态绑定**
6. **从编译和运行的角度看方法的重载和重写**
   - **重载,**提指允许存在多个同名方法,而这些方法的参数不同。编译器根据方法不同的参数表,对同名方法的名称做修饰。对于编译器而言,这些同名方法就成了不同的方法。**它们的调用地址在编译期就绑定了**。Java的重载是可以包括父类和子类的,即子类可以重载父类的同名不同参数的方法。所以:对于重载而言,在方法调用之前,编译器就已经确定了所要调用的方法,,这称为**“早绑定”或“静态绑定**”而对于**多态**,**只有等到方法调用的那一刻,编译器才会确定所要调用的具体方法**,这称为**“晚绑定”或“动态绑定”**引用一句Bruce Eckel的话: “**不要犯傻,如果它不是晚绑定,它就不是多态**。
7. 为什么**this()或super()**调用语句只能出现在构造器中的第一句？
   - 无论通过哪个构造器创建子类对象，需要保证先初始化父类
   - 目的：当子类继承父类后，“继承”父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化
8. **向下转型**
   - 有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用。
   - **如何才能调用子类特有的属性和方法**？
   - 使用强制类型转换符（）**向下转型**
   - 使用强转时，可能出现Class'CastException的异常
9. 练习：
   - 1·若子类重写了父类方法,就意味着子类里定义的方法彻底覆盖了父类里的同名方法,系统将不可能把父类里的方法转移到子类中:**编译看左边,运行看右边**
   - 2.对于实例变量则不存在这样的现象,即使子类里定义了与父类完全相同的实例变量,这个实例变量依然不可能覆盖父类中定义的实例变量:**编译运行都看左边**

##### instanceof关键字使用

1. **a instanceof A​**:判断对象a是否是类A的实例，如果是返回true，如果不是返回false​
2. 使用情景：为了避免在向下转型时出现ClassCastException异常，在向下转型之前，先进行instanceof的判断，返回true则转型，返回false不进行向下转型

##### java.lang.Object类的使用

1. Object类是所有Java类的根父类
2. 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类。
3. Object类中的功能（属性，方法）具有通用性
   - 属性：无
   - 方法：**equals()/toString()**/getClass()反射的时候/hashCode()/clone()/finalize()/wait()/notify()/notifyAll()
4. Object类只声明了一个空参构造器
5. 方法：
   - **==**和**equals**的区别
     1. ==既可以比较基本类型也可以比较引用类型。对于**基本类型**（不一定要类型相同）就是比较**值**,对于**引用类型**就是比较**内存地址**
     2. equals的话,它是属于java.lang.Object类里面的方法,如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的,而且String类在日常开发中用的比较多,久而久之,形成了equals是比较值的错误观点。
     3. 具体要看自定义类里有没有重写object的equals方法来判断。
     4. 通常情况下,重写equals方法,会比较类中的相应属性是否都相等。
   - **“==”运算符**
     1. 可以使用在基本数据类型变量和引用数据类型变量中
     2. 若比较的是基本数据类型变量，比较两个变量存在的值是否相同（比一定要类型相同）
     3. 若比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体
   - **equals（）方法的使用**
     1. 是一个方法，而不是运算符
     2. 只能适用于引用数据类型
     3. Object类中equals（）的作用与“==”相同，比较两个对象的地址值是否相同
     4. 像**String,Date,File,包装类**等都重写了Object类中equals方法，重写后不是比较的引用地址，而是比较两个对象的**“实体内容”**是否相同
     5. 通常情况下，自定义的类如果使用equals（）方法的话，也通常是比较两个对象的实体内容是否相同，那么就需要对Object类中的equals（）方法进行重写。
     6. 重写的原则：比较两个对象的实体内容是否相同
   - **Object类中toString()函数**
     1. 当输出一个对象时，实际上是调用当前对象得toString()方法
     2. String，Date,File 包装类都重写了Object类中得 toString()方法，在调用对象的toString方法时，返回“实体内容”信息
     3. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”
   - 
6. 单元测试
   - 步骤
     1. 选中当前工程——右键选择：bulid path  --  add libraries  -  JUnit4  -  下一步
     2. 创建Java类，进行单元测试。
        - 此时Java类要求，1、此类时public，2、此类提供公共的无参构造器
     3. 此类中声明单元测试方法。单元测试方法权限是public，没有返回值，没有形参
     4. 此单元测试方法上一行需要声明注解;**@Test**,并在单元测试类中导入：**import org.junit.test**
     5. 声明好单元测试类方法后，就可以在方法体内测试相关代码
     6. 写完代码以后，左键双击单元测试名，右键：run as   -   JUnit  Test
   - 说明
     1. 执行结果没有任何异常，绿条，异常，红条

##### 包装类（Wrapper)的使用

1. ,针对**八种基本数据类型定义相应的引用类型-包装类(封装类)**,有了类的特点,就可以调用类中的方法, Java才是真正的面问对象
2. ![image-20210809152309872](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210809152309872.png)
3. 基本数据类型，包装类，String三者之间的相互转换。
   - 基本数据类型——>包装类
     1. 调用包装类的构造器
   - 包装类——>基本数据类型
     1. 调用包装类的xxxValue（）方法
   - 基本数据类型，包装类——>String类型
     1. 调用String重载的valueOf(Xxx   xxx)
     2. 用“+”做连接运算
   - String类型——>基本数据类型，包装类
     1. 调用包装类的parseXxx()
4. JDK5.0新特性：**自动拆箱，自动装箱**
5. Integer内部定义了IntegerCach结构，其中定义了Integer[],保存了-128——127范围内时，可以直接使用数组中的元素，不能再去new了，目的：提高效率

##### Static关键字的使用

1. static：静态的

2. static用来修饰：属性，方法，代码块，内部类

3. 修饰属性

   - **静态变量或者类变量**

   - 属性按是否使用static修饰：分为：静态属性和非静态属性（实例变量）

   - 实例变量：当创建了类的对象，每个对象都独立的拥有一套类中的非静态属性，修改其中一个对象中的非静态变量，不会导致其他对象中相同的属性值的修改

   - 静态变量：创建了类的多个对象，多个对象共享同一个静态变量，当通过一个对象修改静态变量时，会导致其他对象调用此静态变量时，值是修改过的。

   - 修饰属性的其他说明：

     - 静态变量随着类的加载而加载，可以通过**“类名.属性”**的方式进行调用

     - 静态变量加载早于对象的创建

     - 由于类只会加载一次，则静态变量在内存中只会存在一份，存在方法区的静态域中

     - 静态属性举例;System.out;Math.PI

       |      | 类变量 | 实例变量 |
       | :--: | :----: | :------: |
       |  类  |  yes   |    no    |
       | 对象 |  yes   |   yes    |

4. **使用static修饰的方法，静态方法**

   - 随着类的加载而加载，可以通过**“类名.方法”**的方式进行调用

   - 静态方法中只能调用静态的方法或属性

   - 对于非静态方法可以调用非静态和静态的属性和方法

   - |      | 静态方法（类） | 非静态方法(对象) |
     | :--: | :------------: | :--------------: |
     |  类  |      yes       |        no        |
     | 对象 |      yes       |       yes        |

     

5. **static注意点**

   - 在静态方法内，不能使用**this和super**关键字
   - 从生命周期的角度去理解静态属性和静态方法

6. 开发中如何确定**一个属性是否要声明为static**？

   - 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
   - 类中的常量也常常声明为static

7. 开发中，如何确定一个**方法是否要声明为static的？**

   - 操作静态属性的方法，通常设置为static的
   - 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections

##### 设计模式和单例设计模式

1. 单例设计模式
   - **所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。**
2. **懒汉式和饿汉式**
   - 懒汉式
     - 好处：延迟对象的创建。
     - 目前的写法坏处：线程不安全。--->到多线程内容时，再修改
   - 饿汉式
     - 坏处：对象加载时间过长。
     - 好处：饿汉式是线程安全的

##### 代码块

1. 代码块的作用：用来初始化**类、对象**
2. 代码块如果有修饰的话，只能使用**static.**
3. 分类：静态代码块  vs 非静态代码块
4. 静态代码块
   - 内部可以有输出语句
   - 随着类的加载而执行,而且只执行一次
   - 作用：初始化类的信息
   - 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
   - 静态代码块的执行要优先于非静态代码块的执行
   - 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
5. 非静态代码块
   - 内部可以有输出语句
   - 随着对象的创建而执行
   - 每创建一个对象，就执行一次非静态代码块
   - 作用：可以在创建对象时，对对象的属性等进行初始化
   - 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
   - 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法

##### final关键字

1. final可以用来修饰的结构：**类、方法、变量**
2. final 用来修饰一个类:**此类不能被其他类所继承。**
   - 比如：String类、System类、StringBuffer类
3. final 用来修饰方法：表明此方法不可以被重写
   - 比如：Object类中getClass();
4. final 用来修饰变量：此时的"**变量"就称为是一个常量**
    *          final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
    *          final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
5. **static final 用来修饰属性：全局常量**

##### 抽象类和抽象方法

1. abstract:抽象的
2. abstract可以用来修饰的结构：类、方法
3. abstract修饰类：**抽象类**
    * 		**此类不能实例化**
    *      **抽象类中一定有构造器，便于子类实例化时调用**（涉及：子类对象实例化的全过程）
    *      **开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作**
4. abstract修饰方法：**抽象方法**
    * 		抽象方法只有方法的声明，没有方法体
    * 		包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。
    *      若子类重写了父类中的所有的抽象方法后，此子类方可实例化
    *        若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

1. abstract使用上的注意点：
   - abstract不能用来修饰：属性、构造器等结构
   - abstract不能用来修饰私有方法、静态方法、final的方法、final的类
2. 多态的应用，模板方法设计模式
   - **抽象类体现的就是一种模板模式的设计,抽象类作为多个子类的通用模·板,子类在抽象类的基础上进行扩展、改造,但子类总体上会保留抽象类的行为方式。**
   - 解决的问题
     - 当功能内部一部分实现是确定的,一部分实现是不确定的。这时可以把不确定的部分暴露出去,让子类去实现。
     - **换句话说,在软件开发中实现一个算法时,整体步骤很固定、通用,这些步骤已经在父类中写好了。但是某些部分易变,易变部分可以抽象出来,供不同子类实现。这就是一种模板模式。**

##### 接口（interface)

1. java中，接口和类是并列的两个结构
2. 如何定义接口，定义接口中的成员？
   - JDK7及以前：只能定义全局常量和抽象方法
     - 全局常量：**public static final，书写时可以省略不写**
     - 抽象方法：**public abstract**
   - **JDK8**：除了定义全局常量和抽象方法，还可以定义**静态方法，默认方法**
     - 接口中定义的静态方法，只能通过接口调用
     - 通过实现类的对象，可以调用接口中的默认方法
     - **如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法**
     - 如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->**类优先原则**
     - 如果实现类实现了**多个接口**，而这多个接口中定义了**同名同参数的默认方法**，**那么在实现类没有重写此方法的情况下，报错。-->接口冲突。**——这就需要我们必须在**实现类中重写此方法**
3. 接口中不能定义构造器，意味着接口不能实例化
4. Java开发中，**接口通过用类去实现（implements)的方式来使用**；如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化；如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
5. **Java类可以实现多个接口 ————>弥补了Java单继承性的局限性**
   - 格式：**class** AA **extends** BB **implements** CC,DD,EE
6. 接口与接口之间可以继承，而且可以多继承
7. 接口的具体使用体现**多态性**
8. 接口，实际上可以看作是一种规范
9. 接口的使用：
   - 接口使用上也满足多态性
   - 接口实际上就是定义了一种规范
   - 开发中体会面向接口编程
   - **代理模式**
     - 安全代理
     - 远程代理
     - 延迟加载
     - 静态代理
     - 动态代理

##### 内部类（类的内部成员之五）

1. Java中允许将一个类A声明在另一个类B中，则**类A就是内部类，类B称为外部类**
2. 内部类的分类：**成员内部类**（静态、非静态）  vs **局部内部类**(方法内、代码块内、构造器内)
3. 成员内部类
   - 一方面，作为外部类的成员：
     - 调用外部类的结构
     - 可以被static修饰
     - 可以被4种不同的权限修饰
   - 另一方面，作为一个类：
     - 类内可以定义属性、方法、构造器等
     - 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
     - 可以被abstract修饰
4. 关注如下的3个问题
   - 如何实例化成员内部类的对象
   - 如何在成员内部类中区分调用外部类的结构
   - 开发中局部内部类的使用  见《InnerClassTest1.java》

##### 异常

1.  Error:Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。
2. ![image-20210816133412418](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210816133412418.png)
3. 红色为编译时异常（受检异常），蓝色为运行时异常（非受检异常）
4. **异常体系结构**
   - java.lang.Throwable
     1. java.lang.Error:一般不编写针对性的代码进行处理。
     2. java.lang.Exception:可以进行异常的处理
        - 编译时异常(checked)
          1. IOException
             - FileNotFoundException
          2. ClassNotFoundException
        - 运行时异常(unchecked,RuntimeException)
          1. NullPointerException
          2. ArrayIndexOutOfBoundsException
          3. ClassCastException
          4. NumberFormatException
          5. InputMismatchException
          6. ArithmeticException
5. **异常处理机制**
   - 异常的处理**抓抛模型**
     - 过程一：”抛“：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。 并将此对象抛出，一旦抛出对象以后，其后的代码就不再执行。
       - 异常对象的产生：①	系统自动生成的异常对象，②手动的生成一个异常对象，并抛出（throw)
     -  过程二：“抓”：可以理解为异常的处理方式：①try-catch -finally;②throws
   - **try -catch-finally的使用**
     - finally是可选的
     - 使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象类型，去catch中进行匹配
     - 一旦try中的异常对象匹配到一个catch时，就进入catch中进行异常处理，一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况下）继续执行其后的代码
     - catch中的异常类型如**果没有子父类关系**，则谁声明在上，谁声明在下无所谓
     - catch中的异常类型如果**满足子父类关系**，则要求子类一定要声明在父类的上面，否则报错
     - 常用异常对象处理的方式：
       - String  getMessage()
       - printStackTrace（）
     - 在try结构中声明的变量，出了try结构以后，就不能被调用
     - 使用try-catch -finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍有可能报错，相当于将编译时可能出现的异常，延迟到运行时出现。
     - 开发中，由于运行时异常比较常见，所以通常不针对运行时异常编写try-catch-finally了，针对编译时异常，一定要考虑异常的处理
   - try -catch-finally中finally的使用
     - finally是可以选择的
     - finally中声明的是一定会被执行的代码。即catch中又出现了异常，try中有return语句，catch中有return语句等情况
     - 像**数据库连接、输入输出流、网络编程Socket等资源**，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。
   - **异常处理二：throws+异常类型**
     - 写在方法的声明处，指明方法执行时，可能会抛出的异常类型，一旦当方法执行时出现异常， 仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。**异常代码的后续代码就不会再被执行**
   - **try -catch-finally的使用**真正的将异常给处理掉了，throws的方式只是将异常抛给了方法的调用者，并没有将异常处理掉。
6. **重写方法异常抛出的规则：**
   - 子类重写的方法抛出的异常类型**不大于父类**被重写方法抛出的异常类型，
7. **开发中如何选择try-catch-finally还是throws？**
   - 如果父类中被重写的方法没有throws方法处理异常，子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用**try-catch-finally**方式处理
   - 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议**这几个方法使用throws的方式**进行处理。而执行的**方法a可以考虑使用try-catch-finally方式进行处理。**
8. **手动抛出异常**
9. **自定义异常类**
   - 如何自定义异常类？
     - 继承于现有的异常结构：RuntimeException,Exception
     - 提供全局常量：serialVersionUID
     - 提供重载构造器

