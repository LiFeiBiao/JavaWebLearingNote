## OSI和TCP/IP各层的结构与功能

![image-20210926102128092](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926102128092.png)

### 应用层

1. **应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用**，应用层协议定义的是应用**进程**（进程：主机中正在运行的程序）间的**通信和交互**的规则，如**域名系统 DNS**，支持万维网应用的 **HTTP 协议**，支持电子邮件的 **SMTP 协议**，交互的**数据单元称为报文**

2. **域名系统**

   **域名系统(Domain Name System 缩写 DNS，Domain Name 被译为域名)是因特网的一项核心服务**，它作为可以**将域名和 IP 地址相互映射的一个分布式数据库**，能够使人更方便的访问互联网，而**不用去记住**能够被机器直接读取的 **IP 数串**。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 [www.ibm.com、Oracle](http://www.ibm.xn--comoracle-xj3h/) 公司的域名是 [www.oracle.com、Cisco](http://www.oracle.xn--comcisco-hm3g/) 公司的域名是 [www.cisco.com](http://www.cisco.com/) 等

3. **HTTP协议**

   **超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议**。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）

### 运输层

**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**，应用进程利用该服务**传送应用层报文。**“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。**由于一台主机可同时运行多个线程**，因此运输层有**复用和分用**的功能。所谓**复用就是指多个应用层进程可同时使用下面运输层的服务**，**分用是运输层把收到的信息分别交付上面应用层中的相应进程。**

1. **协议**

   1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
   2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）

2. ![image-20210926103036098](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926103036098.png)

3. **UDP** 在传送数据之前**不需要先建立连接**，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

   **TCP 提供面向连接的服务**。在传送数据之前必须**先建立连接**，数据传送结束**后要释放连接**。 TCP **不提供广播或多播**服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据**之前**，**会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制**，在数据传完**后，还会断开连接**用来节约系统资源），这一难以避免增加了许多开销，如**确认，流量控制，计时器以及连接管理**等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。**TCP 一般用于文件传输、发送和接收邮件、远程登录**等场景。



### 网络层

在**计算机网络中进行通信的两个计算机之间**可能会经过很多个**数据链路**，也可能还要经过很多**通信子网**。**网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送**。 在发送数据时，网络层把运输层产生的**报文段或用户数据报**封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。

这里要注意：**不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混**。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。

这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.

互联网是由大量的**异构（heterogeneous）网络通过路由器（router）**相互连接起来的。互联网使用的**网络层协议是无连接的网际协议（Internet Protocol）**和许多路由选择协议，因此互联网的网络层也叫做**网际层**或**IP 层**。

### 数据链路层

**数据链路层(data link layer)通常简称为链路层**。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的**控制信息**（如**同步信息，地址信息，差错控制**等）。

在接收数据时，**控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束**。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还**使接收端能够检测到所收到的帧中有无差错**。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，**数据链路层不仅要检错，而且还要纠错**），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。

### 物理层

在物理层上所传送的数据**单位是比特**。

**物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，** 使其上面的数据链路层不必考虑网络的**具体传输介质是什么**。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议族。

### 总结

![七层体系结构图](https://snailclimb.gitee.io/javaguide/docs/cs-basics/network/images/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)

## TCP 三次握手和四次挥手(面试常客)

### 三次握手图解

![image-20210926105439381](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926105439381.png)

- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

![image-20210926105521869](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926105521869.png)

### 为什么三次握手

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：**自己发送**、接收正常，对方发送、**接收正常**

所以三次握手就能确认双发收发功能都正常，缺一不可

###  第 2 次握手传回了 ACK，为什么还要传回 SYN？

**接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了**，这表明从客户端到服务端的通信是正常的。而**回传 SYN 则是为了建立并确认从服务端到客户端的通信**。”

> **SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号**。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

### 为什么四次挥手

![image-20210926120142626](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926120142626.png)

断开一个 TCP 连接则需要“四次挥手”：

- **客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送**
- **服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号**
- **服务器-关闭与客户端的连接，发送一个 FIN 给客户端**
- **客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

## TCP协议如何包证可靠传输

1. 应用数据被分割成 TCP 认为**最适合发送的数据块**。
2. TCP 给发送的**每一个包进行编号**，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它**首部和数据的检验和**。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会**丢弃重复的数据**。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，**TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据**。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是**可变大小的滑动窗口协议**。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ 协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

#### ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是 **OSI 模型中数据链路层和传输层的错误纠正协议之一**。它通过使用**确认和超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括**停止等待 ARQ 协议和连续 ARQ 协议**。

1. #### 停止等待 ARQ 协议

   停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，**等待对方确认（回复 ACK）**。如果过了一段时间（超时时间后），还是**没有收到 ACK 确认**，说明没有发送成功，需**要重新发送**，直到收到确认后再发下一个分组。

   在停止等待协议中，若接收方**收到重复分组，就丢弃该分组**，但同时还要发送确认。

   **优缺点：**

   - **优点：** 简单
   - **缺点：** 信道利用率低，等待时间长

   **1) 无差错情况:**

   发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。

   **2) 出现差错情况（超时重传）:**

   停止等待协议中**超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组**（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个**超时计时器**，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。**连续 ARQ 协议** **可提高信道利用率**。发送维持一个**发送窗口**，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用**累积确认**，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。

   **3) 确认丢失和确认迟到**

   - **确认丢失** ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. **丢弃这个重复的 M1** 消息，不向上层交付。 2. **向 A 发送确认消息。**（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。
   - **确认迟到** ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. **A 收到重复的确认后，直接丢弃**。2. B 收到重复的 M1 后，**也直接丢弃重复的 M1**。

2. #### **连续ARQ协议**

   连续 ARQ 协议**可提高信道利用率**。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用**累计确认**，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

   **优缺点：**

   - **优点：** **信道利用率高，容易实现，即使确认丢失，也不必重传**。
   - **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。**这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。**

#### 滑动窗口和流量控制

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

#### 拥塞控制

![image-20210926130002513](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926130002513.png)

在某段时间，**若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏**。这种情况就叫**拥塞**。**拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载**。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，**涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素**。相反，**流量控制往往是点对点通信量的控制，是个端到端的问题**。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。**拥塞控制窗口的大小取决于网络的拥塞程度**，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP 的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以**使路由器采用适当的分组丢弃策略**（如**主动队列管理 AQM**），以减少网络拥塞的发生。

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。**cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍**。
- ![image-20210926130035746](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926130035746.png)
- ![image-20210926130125488](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926130125488.png)
- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 **cwnd 加 1.**
- **快重传与快恢复：** 在 TCP/IP 中，**快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法**，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认**。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。**有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。
- ![image-20210926130402624](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926130402624.png)
- ![image-20210926130437775](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926130437775.png)

## 在浏览器中输入 url 地址 ->> 显示主页的过程(面试常客)

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg)

**是 OSPF** 不是 OPSF。 **OSPF（Open Shortest Path First，ospf）开放最短路径优先协议**,是由 Internet 工程任务组开发的路由选择协议

1. **DNS 解析**
2. **TCP 连接**
3. **发送 HTTP 请求**
4. **服务器处理请求并返回 HTTP 报文**
5. **浏览器解析渲染页面**
6. **连接结束**

## 状态码

![image-20210926131852927](C:\Users\17391\AppData\Roaming\Typora\typora-user-images\image-20210926131852927.png)

## 各种协议和HTTP协议之间的关系

![各种协议与HTTP协议之间的关系](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

## HTTP长连接，短连接

在 **HTTP/1.0 中默认使用短连接**。也就是说，**客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接**。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

而从 **HTTP/1.1 起，默认使用长连接，用以保持连接特性**。使用长连接的 HTTP 协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。**Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接**。

**HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。**

## HTTP 是不保存状态的协议,如何保存用户状态?

**HTTP 是一种不保存状态，即无状态（stateless）协议**。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？**Session 机制**的存在就是为了解决这个问题，**Session 的主要作用就是通过服务端记录用户的状态**。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。**服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了**（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

在服务端**保存 Session 的方法**很多，最常用的就是**内存和数据库**(比如是使用**内存数据库 redis 保存**)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 **Cookie 中附加一个 Session ID 来方式来跟踪**。

**Cookie 被禁用怎么办?**

最常用的就是**利用 URL 重写把 Session ID 直接附加在 URL 路径的后面**。

![HTTP是无状态协议](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png)

## Cookie 的作用是什么?和 Session 有什么区别？

**Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式**，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 **Token 在 Cookie 中**，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

**Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。**

Cookie 存储在客户端中，而 Session 存储在服务器上，**相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密**。

## HTTP 1.0 和 HTTP 1.1 的主要区别是什么?

HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：

1. **长连接** : **在 HTTP/1.0 中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**HTTP 1.1 起，默认使用长连接** ,默认开启 Connection： keep-alive。 **HTTP/1.1 的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
2. **错误状态响应码** :在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
3. **缓存处理** :在 HTTP1.0 中主要**使用 header 里的 If-Modified-Since,Expires** 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
4. **带宽优化及网络连接的使用** :HTTP1.0 中，存在一些**浪费带宽的现象**，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且**不支持断点续传功能**，HTTP1.1 则在请求头引入了 **range 头域**，它**允许只请求资源的某个部分**，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

## URI和URL的区别是什么？

- **URI(Uniform Resource Identifier) 是统一资源标志符**，可以唯一**标识一个资源。**
- **URL(Uniform Resource Locator) 是统一资源定位符**，可以**提供该资源的路径**。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

## HTTP 和 HTTPS 的区别？

1. **端口** ：**HTTP** 的 URL 由“http://”起始且默认使用端口**80**，而**HTTPS**的URL由“https://”起始且默认使用端口**443**。

2. 安全性和资源消耗：

   **HTTP 协议运行在 TCP 之上，所有传输的内容都是明文**，客户端和服务器端都无法验证对方的身份。**HTTPS 是运行在 SSL/TLS** 之上的 HTTP 协议，**SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密**，加密采用**对称加密**，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

   - **对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快**，典型的对称加密算法有 DES、AES 等；
   - **非对称加密：密钥成对出现**（且根据公钥无法推知私钥，根据私钥也无法推知公钥），**加密解密使用不同密钥**（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，**典型的非对称加密算法有 RSA、DSA** 等。

## get与post区别

1. get是幂等的，代表从服务端获取数据，无论调用多少次产生的结果都是一样的，不会对服务端数据产生变化
2. post向服务端提交数据，服务端数据发生变化，不是幂等的